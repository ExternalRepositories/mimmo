
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="description" content="bitpit is a C++ library for scientific High Performance Computing." />
    <meta name="keywords" content="bitpit, HPC, octree, PABLO, levelset, RBF, mesh, grid" />
    <link rel="shortcut icon" href="/bitpit-private/images/bitpit_icon.ico" type="image/vnd.microsoft.icon" />
    <link rel="stylesheet" type="text/css" href="/bitpit-private/stylesheets/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit-private/stylesheets/base.css" />
    <link rel="stylesheet" type="text/css" href="/bitpit-private/stylesheets/slideshow.css" />
    <script type="text/javascript" src="/bitpit-private/scripts/jquery-1.12.4.min.js"></script>
    <script type="text/javascript">
        $(document).ready(function(){
        });
    </script>
    <meta name="generator" content="Doxygen 1.8.5"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="manual.css" rel="stylesheet" type="text/css"/>
    <title>bitpit - Manual - Operators</title>
</head>
<body>
<!-- Header-->
<div id="header" class="">
    <div class="logo"><a href="/bitpit-private">bitpit</a></div>
    <div class="menu-line"></div>
<ul class="menu">
    <li>
        <span>Modules</span>
        <ul class="sub-menu">
            <li><a href="/bitpit-private/modules/overview.html">Overview</a></li>
            <li><a href="/bitpit-private/modules/PABLO.html">PABLO</a></li>
            <li><a href="/bitpit-private/modules/RBF.html">RBF</a></li>
        </ul>
    </li>
    <li>
        <a href="/bitpit-private/examples">Examples</a>
    </li>
    <li class="current">
        <span>Documentation</span>
        <ul class="sub-menu">
            <li><a href="/bitpit-private/documentation/installation.html">Installation guide</a></li>
            <li><a href="/bitpit-private/documentation/manual/1.2.0/index.xhtml">Programmer's manual</a></li>
        </ul>
    </li>
    <li>
        <a href="/bitpit-private/downloads">Downloads</a>
    </li>
</ul>
<script type="text/javascript">
$('.menu li').hover(
    function() {
        $('ul', this).css('height', 'auto');
        $('ul', this).stop().slideDown(200);
    },
    function() {
        $('ul', this).stop().slideUp(200, function() {
            $(this).attr('style','');
        });
    }
);
</script>
</div>
<div id="content" class="">
<div id="manual">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.xhtml"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.xhtml"><span>Modules</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li><a href="examples.xhtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Operators<div class="ingroups"><a class="el" href="group__operators.xhtml">Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Operators:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__Operators.svg" width="224" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="memitem:ga3f635ef98b56435afb45a039abf9e039"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3f635ef98b56435afb45a039abf9e039"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga3f635ef98b56435afb45a039abf9e039">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3f635ef98b56435afb45a039abf9e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7017c5d06814ac672157b881cc29f086"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga7017c5d06814ac672157b881cc29f086"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga7017c5d06814ac672157b881cc29f086">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7017c5d06814ac672157b881cc29f086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga44d22adb8eb80a55b5379bbc4bcb9422">operator+</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba4d31507040c35f062537329b2f99d"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga3ba4d31507040c35f062537329b2f99d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga3ba4d31507040c35f062537329b2f99d">operator+</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3ba4d31507040c35f062537329b2f99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga46ab5d3f2416d30ad6ed556e513ca15e">operator+</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga71c4e0f1fa74771e27be330e94c98fa1">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga0753f57c13e8860d7d89a3c1d38c2f73">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;<br class="typebreak"/>
, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga6d4f03731e627c861ab285e02d00f7ff">operator+=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da48a189e6261dbea01a0042d36a814"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1da48a189e6261dbea01a0042d36a814"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga1da48a189e6261dbea01a0042d36a814">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1da48a189e6261dbea01a0042d36a814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af61c1b7033247df0338ccce0e612d6"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3af61c1b7033247df0338ccce0e612d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga3af61c1b7033247df0338ccce0e612d6">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga3af61c1b7033247df0338ccce0e612d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579c90a19cace79621439edbc2d4a73b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga579c90a19cace79621439edbc2d4a73b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga579c90a19cace79621439edbc2d4a73b">operator-</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga579c90a19cace79621439edbc2d4a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga458d5cb02f35f9a5d5bb4ec188ff7df9">operator-</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga8afe15fc58c619bd07278b1b2bc1fba9">operator-</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07c4511ff8846e22d929bdefc82cd46"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gae07c4511ff8846e22d929bdefc82cd46"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gae07c4511ff8846e22d929bdefc82cd46">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gae07c4511ff8846e22d929bdefc82cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e0e282c16ff506763346bbabbb27a2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga98e0e282c16ff506763346bbabbb27a2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga98e0e282c16ff506763346bbabbb27a2">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga98e0e282c16ff506763346bbabbb27a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea724ee1533cefef0eeb081a124145f2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaea724ee1533cefef0eeb081a124145f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;<br class="typebreak"/>
, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaea724ee1533cefef0eeb081a124145f2">operator-=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaea724ee1533cefef0eeb081a124145f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga1d7733125c27824e1aa57ebae04b06a8">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4462ec066ada6e0be6054a50670510b9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga4462ec066ada6e0be6054a50670510b9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga4462ec066ada6e0be6054a50670510b9">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga4462ec066ada6e0be6054a50670510b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c63fae35933caafc7d747052b96b2f2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga6c63fae35933caafc7d747052b96b2f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga6c63fae35933caafc7d747052b96b2f2">operator*</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga6c63fae35933caafc7d747052b96b2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga04c59fa6da7fc1146dac00e02084d5d6">operator*</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873023bbde7c283db20e88467cabf3d3"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga873023bbde7c283db20e88467cabf3d3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga873023bbde7c283db20e88467cabf3d3">operator*</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga873023bbde7c283db20e88467cabf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0292340505d2a22841ce7b8960345b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gace0292340505d2a22841ce7b8960345b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gace0292340505d2a22841ce7b8960345b">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gace0292340505d2a22841ce7b8960345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaa3a09d793370ba100f19a3af3ec567a4">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;<br class="typebreak"/>
, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gae4182cfb7e85ce1cf28603be3ea64891">operator*=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaf48b3511fe629a19ad6d343b3722b18f">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga5d819f94a4f2c54f683086dfd60914fe">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f1060376be7df1fdfaf5372216bb03"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga17f1060376be7df1fdfaf5372216bb03"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga17f1060376be7df1fdfaf5372216bb03">operator/</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga17f1060376be7df1fdfaf5372216bb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaa5db31c5d90112637e4d2fa84eee9d7e">operator/</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb62dde4f70707cef0988601e7ae3c08"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gabb62dde4f70707cef0988601e7ae3c08"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gabb62dde4f70707cef0988601e7ae3c08">operator/</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gabb62dde4f70707cef0988601e7ae3c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86745bdc619c80a87b7495a2be35b5be"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga86745bdc619c80a87b7495a2be35b5be"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga86745bdc619c80a87b7495a2be35b5be">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga86745bdc619c80a87b7495a2be35b5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7c612383329df772db1f49839fea19"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga5b7c612383329df772db1f49839fea19"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga5b7c612383329df772db1f49839fea19">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5b7c612383329df772db1f49839fea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50403f99e949516bedf459d21540353c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga50403f99e949516bedf459d21540353c"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;<br class="typebreak"/>
, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga50403f99e949516bedf459d21540353c">operator/=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga50403f99e949516bedf459d21540353c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ad1dc96cc1000aded39aecb5d66493"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gae6ad1dc96cc1000aded39aecb5d66493"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gae6ad1dc96cc1000aded39aecb5d66493">operator&lt;&lt;</a> (std::ostream &amp;out, const std::array&lt; T, d &gt; &amp;x)</td></tr>
<tr class="separator:gae6ad1dc96cc1000aded39aecb5d66493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad637328053776e7bea855be5b5ec3c05"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gad637328053776e7bea855be5b5ec3c05"><td class="memTemplItemLeft" align="right" valign="top">std::ofstream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gad637328053776e7bea855be5b5ec3c05">operator&lt;&lt;</a> (std::ofstream &amp;out, const std::array&lt; T, d &gt; &amp;x)</td></tr>
<tr class="separator:gad637328053776e7bea855be5b5ec3c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ecc3462d869a3132ba96d017ae549b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga91ecc3462d869a3132ba96d017ae549b"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga91ecc3462d869a3132ba96d017ae549b">operator&gt;&gt;</a> (std::istream &amp;in, std::array&lt; T, d &gt; &amp;x)</td></tr>
<tr class="separator:ga91ecc3462d869a3132ba96d017ae549b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab05ccaf89c3e1ee457fefd240b4a8f8"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaab05ccaf89c3e1ee457fefd240b4a8f8"><td class="memTemplItemLeft" align="right" valign="top">std::ifstream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaab05ccaf89c3e1ee457fefd240b4a8f8">operator&gt;&gt;</a> (std::ifstream &amp;in, std::array&lt; T, d &gt; &amp;x)</td></tr>
<tr class="separator:gaab05ccaf89c3e1ee457fefd240b4a8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8e6cb7778b970db759ed66653eaaad"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga8b8e6cb7778b970db759ed66653eaaad"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga8b8e6cb7778b970db759ed66653eaaad">display</a> (std::ostream &amp;out, const std::array&lt; T, d &gt; &amp;x, unsigned int padding)</td></tr>
<tr class="separator:ga8b8e6cb7778b970db759ed66653eaaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f513a6f50b459a57eb8c44c9b80ca75"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga4f513a6f50b459a57eb8c44c9b80ca75"><td class="memTemplItemLeft" align="right" valign="top">std::ofstream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga4f513a6f50b459a57eb8c44c9b80ca75">display</a> (std::ofstream &amp;out, const std::array&lt; T, d &gt; &amp;x, unsigned int padding)</td></tr>
<tr class="separator:ga4f513a6f50b459a57eb8c44c9b80ca75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga71b722bb9670854ddfcb0e867620083f">operator+</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga71b722bb9670854ddfcb0e867620083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga97948a906b46303c7c654c84149dd9ee">operator+</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga97948a906b46303c7c654c84149dd9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gade9e3b35c5ed9d228bd242eaee48df2f">operator+</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga06cb1fde86b09befdc0b42d99fdbf31f">operator+</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga6e163effd6e58c7f726fbd29f5c1e42c">operator+</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga4a54e162a0893a716a8e767bccc5bcf6">operator+=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043993b9b79a9ae8c6311907bf739c83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043993b9b79a9ae8c6311907bf739c83"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga043993b9b79a9ae8c6311907bf739c83">operator+=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043993b9b79a9ae8c6311907bf739c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaf7b6c9177a03b67eb4d3746d11295984">operator+=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga39b3f7b4938cab605085cc4a2621c0c1">operator-</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga8b14f28bd4c6544e7af363162827a3f9">operator-</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga81916c6a47f24b1ec5bfb890a7e71d93">operator-</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gacd869d6ee14d5683b3fa4fcefc5ae5fa">operator-</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga043799b065672b453653cccc836df3e0">operator-</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043799b065672b453653cccc836df3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aacb9fe943aadde419e168ee051f35f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0aacb9fe943aadde419e168ee051f35f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga0aacb9fe943aadde419e168ee051f35f">operator-=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga0aacb9fe943aadde419e168ee051f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2595b252e76781008f28f0d4259abd6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac2595b252e76781008f28f0d4259abd6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gac2595b252e76781008f28f0d4259abd6">operator-=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac2595b252e76781008f28f0d4259abd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga8734f21e1ba10ab0e30ca2d98ac458c7">operator-=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga2bd9e5a66f35bd5cfe4903f2405c87ba">operator*</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gac44d2a365e67d48fc144cf576f4e003e">operator*</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac44d2a365e67d48fc144cf576f4e003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga92fa8968855d071e34808339503fe37b">operator*</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga92fa8968855d071e34808339503fe37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gae5c14d292d187b6a76d4acd8068e2ec3">operator*</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga5be9b506ad98c26a66c46e3a63569af2">operator*</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e59ed744d940c52f17237762edeb63"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga53e59ed744d940c52f17237762edeb63"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga53e59ed744d940c52f17237762edeb63">operator*=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga53e59ed744d940c52f17237762edeb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga7bb44d4987361a698f36b0b43da90ec7">operator*=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga56a1b2553cf1c204e208ddf55fdfbff0">operator*=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga4d9d274530965b0fb1a331706535b2b0">operator/</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4d9d274530965b0fb1a331706535b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga9ee9c85d60d975df735a1c35fcf02e20">operator/</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gac6fff4de3b1f6cbedc8b80e0f29b673f">operator/</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaaa8866a1e9873585704acfa8169ba1f4">operator/</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gab73845b94584f17c7e810e27cba36f5d">operator/</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gab73845b94584f17c7e810e27cba36f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gabef2e8a23bc01ea9a02f8478705a8055">operator/=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c760c866b18096f41015d84c1ba517"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad1c760c866b18096f41015d84c1ba517"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gad1c760c866b18096f41015d84c1ba517">operator/=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gad1c760c866b18096f41015d84c1ba517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661186ca419d7b771ea549dc2bee4229"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga661186ca419d7b771ea549dc2bee4229"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga661186ca419d7b771ea549dc2bee4229">operator/=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga661186ca419d7b771ea549dc2bee4229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49746185f37a374b3443aac9437a813"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf49746185f37a374b3443aac9437a813"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#gaf49746185f37a374b3443aac9437a813">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:gaf49746185f37a374b3443aac9437a813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01799f45a32fe28dc2048086d01be8c0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga01799f45a32fe28dc2048086d01be8c0"><td class="memTemplItemLeft" align="right" valign="top">std::ofstream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga01799f45a32fe28dc2048086d01be8c0">operator&lt;&lt;</a> (std::ofstream &amp;out, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ga01799f45a32fe28dc2048086d01be8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2b65156e57615b6b4c9b8cfc416d9d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9d2b65156e57615b6b4c9b8cfc416d9d"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga9d2b65156e57615b6b4c9b8cfc416d9d">operator&gt;&gt;</a> (std::istream &amp;in, std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ga9d2b65156e57615b6b4c9b8cfc416d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c2c7217c9182a68dd8b087507725a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga10c2c7217c9182a68dd8b087507725a0"><td class="memTemplItemLeft" align="right" valign="top">std::ifstream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga10c2c7217c9182a68dd8b087507725a0">operator&gt;&gt;</a> (std::ifstream &amp;in, std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ga10c2c7217c9182a68dd8b087507725a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a403b0e97ae0fa79b2c6767904dcc6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_scalar&lt; T &gt;::value &gt;::type * &gt; </td></tr>
<tr class="memitem:ga03a403b0e97ae0fa79b2c6767904dcc6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga03a403b0e97ae0fa79b2c6767904dcc6">display</a> (std::ostream &amp;out, const T &amp;x)</td></tr>
<tr class="separator:ga03a403b0e97ae0fa79b2c6767904dcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca72400c4fa2b08cfe882aaeada2e54"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4ca72400c4fa2b08cfe882aaeada2e54"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga4ca72400c4fa2b08cfe882aaeada2e54">display</a> (std::ostream &amp;out, const std::vector&lt; T &gt; &amp;x, unsigned int padding)</td></tr>
<tr class="separator:ga4ca72400c4fa2b08cfe882aaeada2e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54374df958a661e200aa96eb18278ed9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_scalar&lt; T &gt;::value &gt;::type * &gt; </td></tr>
<tr class="memitem:ga54374df958a661e200aa96eb18278ed9"><td class="memTemplItemLeft" align="right" valign="top">std::ofstream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga54374df958a661e200aa96eb18278ed9">display</a> (std::ofstream &amp;out, const T &amp;x)</td></tr>
<tr class="separator:ga54374df958a661e200aa96eb18278ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b25bb7c2aadf7c2a6e6fe905cc4db2b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7b25bb7c2aadf7c2a6e6fe905cc4db2b"><td class="memTemplItemLeft" align="right" valign="top">std::ofstream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.xhtml#ga7b25bb7c2aadf7c2a6e6fe905cc4db2b">display</a> (std::ofstream &amp;out, const std::vector&lt; T &gt; &amp;x, unsigned int padding)</td></tr>
<tr class="separator:ga7b25bb7c2aadf7c2a6e6fe905cc4db2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8b8e6cb7778b970db759ed66653eaaad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; display </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display array in a nicely formatted to a std::ostream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array to be displayed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>(default = 0) number of trailing spaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to output stream </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01477">1477</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f513a6f50b459a57eb8c44c9b80ca75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream&amp; display </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display array in a nicely formatted to a std::ofstream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output file stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array to be displayed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>(default = 0) number of trailing spaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to output stream </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01517">1517</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga03a403b0e97ae0fa79b2c6767904dcc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_scalar&lt; T &gt;::value &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; display </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dummy function for recursive templated routines display</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>variable to be displayed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to output stream </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01519">1519</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ca72400c4fa2b08cfe882aaeada2e54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; display </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display vector in a nicely formatted to a std::ostream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>vector to be displayed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>(default = 0) number of trailing spaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to output stream </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01547">1547</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga54374df958a661e200aa96eb18278ed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_scalar&lt; T &gt;::value &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream&amp; display </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dummy function for recursive templated routines display</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>variable to be displayed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to output stream </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01586">1586</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7b25bb7c2aadf7c2a6e6fe905cc4db2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream&amp; display </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display vector in a nicely formatted to a std::ofstream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output file stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>vector to be displayed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>(default = 0) number of trailing spaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to output stream </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01614">1614</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga2bd9e5a66f35bd5cfe4903f2405c87ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] * y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00703">703</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d7733125c27824e1aa57ebae04b06a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between two arrays (x and y) and returns a array z s.t. z[i] = x[i] * y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00715">715</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac44d2a365e67d48fc144cf576f4e003e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] * y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00743">743</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4462ec066ada6e0be6054a50670510b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] * y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00754">754</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga92fa8968855d071e34808339503fe37b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x * y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00783">783</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c63fae35933caafc7d747052b96b2f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x * y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00793">793</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae5c14d292d187b6a76d4acd8068e2ec3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00821">821</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga04c59fa6da7fc1146dac00e02084d5d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::array, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00831">831</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5be9b506ad98c26a66c46e3a63569af2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00862">862</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga873023bbde7c283db20e88467cabf3d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::array, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00871">871</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga53e59ed744d940c52f17237762edeb63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00901">901</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gace0292340505d2a22841ce7b8960345b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00911">911</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7bb44d4987361a698f36b0b43da90ec7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00940">940</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa3a09d793370ba100f19a3af3ec567a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00949">949</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga56a1b2553cf1c204e208ddf55fdfbff0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00979">979</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae4182cfb7e85ce1cf28603be3ea64891"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00987">987</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga71b722bb9670854ddfcb0e867620083f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] + y[i] for all i = 0, ..., n-1 where n = std::min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00069">69</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f635ef98b56435afb45a039abf9e039"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array</p>
<p>Perform the element-wise sum between two arrays (x and y) and returns a array z s.t. z[i] = x[i] + y[i] for all i = 0, ..., d where d = x.size() = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00074">74</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga97948a906b46303c7c654c84149dd9ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] + y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00109">109</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7017c5d06814ac672157b881cc29f086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] + y for all i = 0, ..., d where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00113">113</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gade9e3b35c5ed9d228bd242eaee48df2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x + y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00149">149</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga44d22adb8eb80a55b5379bbc4bcb9422"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x + y[i] for all i = 0, ..., d where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00152">152</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga06cb1fde86b09befdc0b42d99fdbf31f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00187">187</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ba4d31507040c35f062537329b2f99d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00190">190</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e163effd6e58c7f726fbd29f5c1e42c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00228">228</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga46ab5d3f2416d30ad6ed556e513ca15e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00230">230</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a54e162a0893a716a8e767bccc5bcf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00267">267</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga71c4e0f1fa74771e27be330e94c98fa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00268">268</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0753f57c13e8860d7d89a3c1d38c2f73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00306">306</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga043993b9b79a9ae8c6311907bf739c83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00306">306</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d4f03731e627c861ab285e02d00f7ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00344">344</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7b6c9177a03b67eb4d3746d11295984"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00345">345</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1da48a189e6261dbea01a0042d36a814"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between two arrays (x and y) and returns a array z s.t. z[i] = x[i] - y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with n elements, storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00385">385</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga39b3f7b4938cab605085cc4a2621c0c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] - y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00386">386</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga3af61c1b7033247df0338ccce0e612d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] - y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00424">424</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b14f28bd4c6544e7af363162827a3f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] - y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00426">426</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga579c90a19cace79621439edbc2d4a73b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x - y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00463">463</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga81916c6a47f24b1ec5bfb890a7e71d93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x - y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00466">466</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga458d5cb02f35f9a5d5bb4ec188ff7df9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::array, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00501">501</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacd869d6ee14d5683b3fa4fcefc5ae5fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::vector, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00504">504</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8afe15fc58c619bd07278b1b2bc1fba9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., e-1, i = 0, ..., d-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::array, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00541">541</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga043799b065672b453653cccc836df3e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::vector, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00545">545</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae07c4511ff8846e22d929bdefc82cd46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the corresping value on the array at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00579">579</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0aacb9fe943aadde419e168ee051f35f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the corresping value on vector at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00584">584</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga98e0e282c16ff506763346bbabbb27a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::array, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00617">617</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac2595b252e76781008f28f0d4259abd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::vector, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00623">623</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8734f21e1ba10ab0e30ca2d98ac458c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::vector, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l00662">662</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaea724ee1533cefef0eeb081a124145f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::array, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l00674">674</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d9d274530965b0fb1a331706535b2b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] / y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01020">1020</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf48b3511fe629a19ad6d343b3722b18f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between two arrays (x and y) and returns a array z s.t. z[i] = x[i] / y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01028">1028</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ee9c85d60d975df735a1c35fcf02e20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] / y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01060">1060</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5d819f94a4f2c54f683086dfd60914fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] / y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01067">1067</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac6fff4de3b1f6cbedc8b80e0f29b673f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x / y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01105">1105</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga17f1060376be7df1fdfaf5372216bb03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x / y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01111">1111</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa8866a1e9873585704acfa8169ba1f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01146">1146</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5db31c5d90112637e4d2fa84eee9d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01151">1151</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab73845b94584f17c7e810e27cba36f5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01187">1187</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabb62dde4f70707cef0988601e7ae3c08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01191">1191</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabef2e8a23bc01ea9a02f8478705a8055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01229">1229</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga86745bdc619c80a87b7495a2be35b5be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01231">1231</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b7c612383329df772db1f49839fea19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01261">1261</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad1c760c866b18096f41015d84c1ba517"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01268">1268</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga50403f99e949516bedf459d21540353c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01291">1291</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga661186ca419d7b771ea549dc2bee4229"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01307">1307</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae6ad1dc96cc1000aded39aecb5d66493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insertion operator for std::array.</p>
<p>Flush the content of std::array to std::ostream. The content of the input array is flushed with the following format: x[0] x[1] x[2] ... x[d-1] where d = x.size(); (i.e. array elements are separated by blank spaces). Template parameter T can be any type such that operator&lt;&lt; is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument of insertion operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01320">1320</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf49746185f37a374b3443aac9437a813"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insertion operator for std::vector.</p>
<p>Flush the content of std::vector to std::ostream. The content of the input vector is flushed with the following format: x[0] x[1] x[2] ... x[n-1] where n = x.size(); (i.e. vector elements are separated by blank spaces). Template parameter T can be any type such that operator&lt;&lt; is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument of insertion operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01344">1344</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad637328053776e7bea855be5b5ec3c05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insertion operator for std::array.</p>
<p>Flush the content of std::array to std::ofstream. The content of the input array is flushed with the following format: x[0] x[1] x[2] ... x[d-1] where d = x.size(); (i.e. array elements are separated by blank spaces). Template parameter T can be any type such that operator&lt;&lt; is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output file stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument of insertion operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01359">1359</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga01799f45a32fe28dc2048086d01be8c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insertion operator for std::vector.</p>
<p>Flush the content of std::vector to std::ofstream. The content of the input vector is flushed with the following format: x[0] x[1] x[2] ... x[n-1] where n = x.size(); (i.e. vector elements are separated by blank spaces). Template parameter T can be any type such that operator&lt;&lt; is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>output file stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>argument of insertion operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01386">1386</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga91ecc3462d869a3132ba96d017ae549b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extraction operator for std::array.</p>
<p>Extract the content of std::array from std::istream. The content of the input array is extracted until end-of-stream condition is met or all available position in the array are filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>argument of extraction operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to input stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01398">1398</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d2b65156e57615b6b4c9b8cfc416d9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extraction operator for std::vector.</p>
<p>Extract the content of std::vector from std::istream. The content of the input vector is extracted until end-of-stream condition is met. Element extracted from the stream are copyied into vector starting from position 0. When all the availble position within the vector have been overwritten, further elements will be added to the container using push_back, therefore increasing container's size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>argument of extraction operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to input stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01433">1433</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaab05ccaf89c3e1ee457fefd240b4a8f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ifstream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extraction operator for std::array.</p>
<p>Extract the content of std::array from std::ifstream. The content of the input array is extracted until end-of-stream condition is met or all available position in the array are filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input file stream </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>argument of extraction operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to input file stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__array_8tpp_source.xhtml#l01438">1438</a> of file <a class="el" href="Operators__array_8tpp_source.xhtml">Operators_array.tpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga10c2c7217c9182a68dd8b087507725a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ifstream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extraction operator for std::vector.</p>
<p>Extract the content of std::vector from std::ifstream. The content of the input vector is extracted until end-of-file condition is met. Element extracted from the stream are copyied into vector starting from position 0. When all the availble position within the vector have been overwritten, further elements will be added to the container using push_back, therefore increasing container's size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input file stream </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>argument of extraction operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to input file stream (allows concatenation) </dd></dl>

<p>Definition at line <a class="el" href="Operators__vector_8tpp_source.xhtml#l01479">1479</a> of file <a class="el" href="Operators__vector_8tpp_source.xhtml">Operators_vector.tpp</a>.</p>

</div>
</div>
</div><!-- contents -->

</div>
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Mon Jul 18 2016 09:46:25 for bitpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
    <div id="footer" >
        <p><strong>OPTIMAD Engineering Srl</strong> - Via Giacinto Collegno 18 - 10143 Torino</p>
        <p>Capitale Sociale euro 10.000,00 i.v. - Iscr. Reg. Impr. Torino C.F. / P.Iva 09359170017 - R.E.A. TO-1045102</p>
        <p><a href="/bitpit-private/privacy.html">Privacy Policy</a></p>
    </div>
</div>
</body>
</html>

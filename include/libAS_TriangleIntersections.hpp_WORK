#ifndef TRIANGLE_INTERSECTION_HPP
#define TRIANGLE_INTERSECTION_HPP

// Standard libs

# include <cmath>
# include <vector>
# include <array>
# include <string>
# include <iostream>
# include <sstream>

// Local libs
# include "Operators.hpp"
# include "customOperators.hpp"
# include "CG_Basics.hpp"
# include "Class_SurfTri.hpp"

/* Class to find intersections
 * triangle-triangle, see "A Fast Triangle-Triangle Intersaction Test - Tomas Möller - 1997 - Journal of Graphic Tools" 
 * ray-triangle using Möller-Trumbore algorithm, see "Fast, Minimum Storage Ray/Triangle Intersection" - Tomas Möller and Ben Trumbore - 1997*/

struct RayIntersectOutput{

	ivector1D	raytr_map; /*!< Collision:support triangle index on constraint */
	dvector1D	raytr_delta; /*!< intersection value */

	RayIntersectOutput();
	RayIntersectOutput(const RayIntersectOutput &);
	void clearRayIntersectOutput();
	RayIntersectOutput & operator=(const RayIntersectOutput &);
};

namespace CG_Custom {


/*!Check vector elements sign accordance. Return true if a sign change is present in one element at least. */
//Developers Note : Need to be promoted to a custom Operator? Don't know yet.
bool sign_check( dvector1D	& vect);

/*!Check if a triangle P1,P2,P3 is crossing a given plane w/ point P and normal n.
 * If not, return false */
bool intersectTrianglePlane( array <double,3 > const &,
						 	 array< double,3 > const &,
						 	 array< double,3 > const &,
						 	 array< double,3 > const &,
						 	 array< double,3 > const &);


/*! Project triangle defined by points P1,P2,P3 on a line defined by an origin O and direction d
 * Find the two possible edge intersections, and return them ordered according to the line direction.
 */
array< array< double, 3 >, 2> planarIntersectionTriangleLine( array <double,3 > const &,
												   	   	   	  array< double,3 > const &,
												   	   	   	  array< double,3 > const &,
												   	   	   	  array< double,3 > const &,
												   	   	   	  array< double,3 > const &);



/*! Triangle Triangle intersections check utility: check intersection between a vertex given triangle belonging to the original geometry
 * and a vertex given triangle belonging to constraint geometry. Return true if a collision occurs.
 */
bool intersect_TriTri(array< array < double, 3 >, 3 > &, array< array < double, 3 >, 3 > & );


};

class TRIANGLE_INTERSECTIONS{
	public:

	Class_SurfTri constraint;
	Class_SurfTri * puntConstraint;
	Class_SurfTri * puntOriginal;

	//Constructor&Destructor
	TRIANGLE_INTERSECTIONS();
 	TRIANGLE_INTERSECTIONS(Class_SurfTri *, Class_SurfTri *);
 	TRIANGLE_INTERSECTIONS(Class_SurfTri *, dvector2D &, ivector2D &);
 	//copy constructor
    TRIANGLE_INTERSECTIONS(const TRIANGLE_INTERSECTIONS&);
	~TRIANGLE_INTERSECTIONS();

	  //assignment operators
	TRIANGLE_INTERSECTIONS & operator=(const TRIANGLE_INTERSECTIONS &);

	/*! Check intersection on triangles between different surfaces. Requires in input:
	 *  - ivector1D & : list of vertices of deformable triangulation, whose support triangles must be
	 *   				checked against the constraint triangulation.
	 *  - ivector2D & : inverse simplex-vertex connectivity map of deformable triangulation
	 *  - ivector1D & : list of constraint triangles intercepted by a deformable vertex displacement. The list size
	 *  				must be identical to the deformable vertex list or an error will occurr.
	 *  - dvector2D & : optional input of external vertex list for deformable triangulation
	 *
	 *  Returns a ivector2D map of intersections occurring to the pair deformable triangle T1/constraint triangle T2
	 */
	 int checkTriangleSupport(ivector1D &, ivector2D &, ivector1D &, dvector2D *);

	/*!Check intersections between a ray w/ origin and direction coming from the original geometry
	 * and the constraint geometry.
	 */
	RayIntersectOutput intersect_RayTri(dvector1D 	& origin, dvector1D	& direction);

};


#endif //TRIANGLE_INTERSECTIONS_HPP

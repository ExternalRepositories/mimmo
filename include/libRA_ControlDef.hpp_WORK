#ifndef _LIBRA_CONTROLDEF_
#define _LIBRA_CONTROLDEF_

// controller class for LATTICES AND ADAPTiVITY for  Free Form Deformation
#include "libRA_SurfLattice.hpp"
#include "libRA_AdaptiveLattice.hpp"
using namespace std;

/*! Class of Control of multiLattice deformation. Lattice are organized in a std vector. The position of a LATTICE in the vector
 * qualifies the Lattice itself, and mark what is appointed as "the Lattice's name" in this Documentation.
 * the Class constructor reads the information necessary to build Lattice from an external file. See latticesDict.dat as template for such file  */
  class ControlDeformation
	{
	public:
	//Members
	  std::string input_folder;
	  int nLattices; 			        /*!< Identifies the total number of lattices present in the scenegraph */
	  int adaptivity_level;             /*!< read the max adaptivity level for all or part of Lattices */
	  svector1D fileAdaptivity;         /*!< list of string containing the file name for adaptation proc */

	  std::vector<LATTICE<3,4> > morphLattices;  /*!< std::vector structure of Lattices, for multiLattice deformation */
	  std::vector<std::vector<ADAPTIVE_LATTICE<3,4> > > adaptivityList; /*!< std::vector matrix of adaptive Lattices, for multiLattice and multivel adaptivity */

	//Constructor
	/*! Resize the ControlDeformation::morphLattices vector and read the input of each single Lattice from an external file inputFile.
 	 *  See the file template latticesDict.dat for further information on such inputs. This function read also the nodes' displacements applied
 	 *  to each Lattice grid, from an external file, indicated in latticesDict.dat. A template of this file is avalaible in the file load.dat  */
	 ControlDeformation (std::string, std::string );
	 ~ControlDeformation();

	 //method read adaptivity.
	 /*! method to read the adaptivity files */
	 void setAdaptivity();
	 void readAdaptivityLoads();
	 void writeAdaptivityLoads();
//	private:
	 bool checkOrderingAdaptivityFile();
	 void readAdaptivityFile(std::string &);
	 LATTICE<3,4>* findLattice(int, std::string &);

	 /*! get number of lattices in lattice dictionaries-->setting nLattices member */
	 void readNumberLattices(ifstream &);
	 /*! read adaptivity info in lattice dictionaries */
	 void readAdaptLevel(ifstream &, std::string &);
	 /*! read and returns lattice name in lattice dictionaries */
	 std::string readLatticeName(ifstream &);
	 /*! get refinement Flag 0/1 in lattice dictionaries */
	 bool readRefineFlag(ifstream &);
	 /*! read whole flag 0/1 in lattice dictionaries */
	 bool readWholeFlag(ifstream &);
	 /*! read and return level set info (engine method)in lattice dictionaries. return eventually the double parameter for heatTime */
	 bool readLevelSetInfo(ifstream &, std::string &, double &);
	 /*! read and return selection mode info in lattice dictionaries.Return eventually string for selection file name */
	 void readSelectionMode(ifstream &, std::string &, std::string &, std::string &);
	 /*! get lattice characteristics such as origin, span and dimension in lattice dictionaries */
	 ivector1D readLatticeDim(ifstream &, dvector1D&, dvector1D& );
	 /*! read BC info in lattice dictionaries. Returns vector of BCS. According to its size 2 type of methods can be selectioned:
	  * 1) DEFAULT: general method to impose a unique condition at the boundary and one to the interior of deformable patch.
	  *    It employs a transitional parameter to modulate transition from the boundary. Other output are dummies.
	  * 2) SEGMENTED: particular method to segment the boundary of the patch in four branches. it can carry different bc's on
	  *    different branches. It needs a vector of the four geometry file names neighbors of the deformable patch. Other output are dummies*/
	 bvector1D readBoundaryConditions(ifstream &, std::string & folder, ivector1D & bcs, double & transition, dvector1D & seed, svector1D & neigh_geos);
	 /*! read load file name in lattice dictionaries */
	 std::string readLoadFileInfo(ifstream &, std::string &);
	 /*! read end lattice */
	 void readEndLattice(ifstream &);





	}; //end of class ControlDeformation

  /*! Class of Control of multiSurfaceLattice deformation. Lattice are organized in a std vector. The position of a LATTICE in the vector
   * qualifies the Lattice itself, and mark what is appointed as "the Lattice's name" in this Documentation.
   * the Class constructor reads the information necessary to build Lattice from an external file. See latticesDict.dat as template for such file  */
    class ControlSurfaceDeformation
  	{
  	public:
  	//Members
  	  std::string input_folder;
  	  int nLattices; 			        /*!< Identifies the total number of lattices present in the scenegraph */

  	  std::vector<SURFLATTICE> morphLattices;  /*!< std::vector structure of Lattices, for multiLattice deformation */

  	//Constructor
  	/*! Resize the ControlDeformation::morphLattices vector and read the input of each single Lattice from an external file inputFile.
   	 *  See the file template latticesDict.dat for further information on such inputs. This function read also the nodes' displacements applied
   	 *  to each Lattice grid, from an external file, indicated in latticesDict.dat. A template of this file is avalaible in the file load.dat  */
  	 ControlSurfaceDeformation (std::string, std::string );
  	 ~ControlSurfaceDeformation();
  	 //method read adaptivity.
  	 /*! method to read the adaptivity files */

	 /*! get number of lattices in lattice dictionaries-->setting nLattices member */
	 void readNumberLattices(ifstream &);
	 /*! read and returns lattice name in lattice dictionaries */
	 std::string readLatticeName(ifstream &);
	 /*! get refinement Flag 0/1 in lattice dictionaries */
	 bool readRefineFlag(ifstream &);
	 /*! read whole flag 0/1 in lattice dictionaries */
	 /*! read and return selection mode info in lattice dictionaries.Return eventually string for selection file name */
	 void readSelectionMode(ifstream &, std::string &, std::string &, std::string &);
	 /*! get lattice characteristics such as origin, span and dimension in lattice dictionaries */
	 ivector1D readLatticeDim(ifstream &);
	 /*! read BC info in lattice dictionaries. Returns vector of BCS for bivariant map of selection. Boundary of Selection is always segmented employing two alternative methods :
	  * 1) SEED: auto segmentation-> find four split points (if any) defining four side for the bivariant map.
	  *           and boundary points are reordered clockwise according to a specified seed point. BC's will be applied to each branch following
	  *           such order. BC[0] -> first branch, BC[1] -> second branch etc...
	  *
	  * 2) BYNEIGHS: particular method to segment the boundary of the patch in four branches. Boundaries will be identified
	  *              providing nighboring external geometries.
	  *
	  * The first key found in the file defines the method. The other is skipped autoamtically.
	  *              */
	 bvector1D readBoundaryConditions(ifstream &, std::string & folder, ivector1D & bcs, dvector1D & seed, svector1D & neigh_geos);
	 std::string readLoadFileInfo(ifstream &, std::string &);
	 /*! read end lattice */
	 void readEndLattice(ifstream &);



  	}; //end of class ControlSurfaceDeformation


#endif //end of _LIBRA_CONTROLDEF_

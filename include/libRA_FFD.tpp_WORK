//
// code segment to be directly included in libRA_FFD.tpp

// coding

template<int Map_Dim>
void FFD_Ext::deformation( dvector2D & vertex,
		dvector2D & result,
		LATTICE<3,Map_Dim> & lattice,
		dvector1D * deformability
)
{


	// Workspace..................................
	int     n_lattice[3]; // dimension, in each direction x,y,z of lattice mesh
	int     n_points, n_lattice_tot; // total dimension of struct SHAPE and LATTICE, respectively
	double  vinculate, check_pid;

	dvector1D val(3,0.0);

	// write the original cloud points in lattice local sdr
	dvector2D coord(vertex.size(), dvector1D(3,0.0));
	coord = vertex;
	freeContainer(result);
	result.resize(coord.size(), dvector1D(3,0.0));
	
	// setting dimensions of lattice for internal use of the function
	for(int intv=0; intv<3; intv++) n_lattice[intv] =  lattice.n[intv];

	// setting dimensions of structures
	n_lattice_tot =  lattice.n_points;
	n_points= lattice.puntSelection->mapMotherV.size() ;

	for(int i_px = 0; i_px < n_points; i_px++)       // counting on shape points selected
	{
		int i_p = lattice.puntSelection->mapMotherV[i_px];

		val = lattice.NurbsEvaluator(coord[i_p]);
		vinculate = FFD_Ext::constraint(i_px, lattice);
		
		if(deformability != NULL) (*deformability)[i_p] = vinculate;
		result[i_p] = vinculate*val;

	} // next i_p - cycling on the point of SupportMesh triangulation

	//terminate your stuff
	for(int I=0; I<coord.size(); I++)
	{// updating the value in *.deform with the effective position of deformed shape points, not only their displacement
		result[I] = result[I] + coord[I];
	} //next I vertex

} //................ end of function deformation

template<int Map_Dim>
void FFD_Ext::deformation(ivector1D & nodesPar, dvector2D & vertex,
		dvector2D & result,
		LATTICE<3,Map_Dim> & lattice,
		dvector1D * deformability
)
{


	// Workspace..................................
	int     n_lattice[3]; // dimension, in each direction x,y,z of lattice mesh
	int     n_points, n_lattice_tot; // total dimension of struct SHAPE and LATTICE, respectively
	double  vinculate, check_pid;

	dvector1D val(3,0.0);

	// write the original cloud points in lattice local sdr
	dvector2D coord(vertex.size(), dvector1D(3,0.0));
	coord = vertex;
	freeContainer(result);
	result.resize(coord.size(), dvector1D(3,0.0));
	
	// setting dimensions of lattice for internal use of the function
	for(int intv=0; intv<3; intv++) n_lattice[intv] =  lattice.n[intv];

	// setting dimensions of structures
	n_lattice_tot =  lattice.n_points;
	n_points= nodesPar.size() ;

	for(int i_px = 0; i_px < n_points; i_px++)       // counting on shape points selected
	{
		int i_p = nodesPar[i_px];

		val = lattice.NurbsEvaluator(coord[i_p]);
		vinculate = FFD_Ext::constraint(i_px, lattice);
		
		if(deformability != NULL) (*deformability)[i_p] = vinculate;
		result[i_p] = vinculate*val;

	} // next i_p - cycling on the point of SupportMesh triangulation

	//terminate your stuff
	for(int I=0; I<coord.size(); I++)
	{// updating the value in *.deform with the effective position of deformed shape points, not only their displacement
		result[I] = result[I] + coord[I];
	} //next I vertex

} //................ end of function deformation




template<int Map_Dim>
void FFD_Ext::deformation( dvector2D & vertex,
						   dvector2D & result,
						   LATTICE<3,Map_Dim> & lattice,
						   SHAPE * Oshape,
						   Class_SurfTri * Cshape,
						   int * controlType,
						   double * controlTol,
						   bool * coplanCheck,
						   Class_UCartMesh3D * Bmesh,
						   dvector1D & Cdistance,
						   dvector1D * deformability)
{

	//HEADCHECK - check coherence on the optional inputs
	bool check1= (controlType!=NULL) && (Cshape ==NULL);
	bool check2= (controlType!=NULL) && (Oshape ==NULL);
	bool check4= (controlType==NULL) && (Cshape !=NULL);

	if(check1 || check2 || check4)
	{
		std::cout<<"Incoherent calling of optional inputs for collision checking."  << '\n' ;
		std::cout<<"Please recheck your call to deformation function in the code" <<'\n' ;
		std::cout<<"Exiting now..."<<'\n';
		exit(1);
	}

	// Workspace..................................
	int     n_lattice[3]; // dimension, in each direction x,y,z of lattice mesh
	int     n_points, n_lattice_tot; // total dimension of struct SHAPE and LATTICE, respectively
	double  vinculate, check_pid;

	int globCounterCollision=0;
	int failCollision=0;
	TRIANGLE_INTERSECTIONS insectK;
	dvector1D allowDisp;
	ivector1D allowSupp;
	ivector1D mapCollision;
	double tolerance = 0.0;
	dvector1D val(3,0.0);

	// write the original cloud points in lattice local sdr
	dvector2D coord(vertex.size(), dvector1D(3,0.0));
	coord = vertex;
	
	dvector2D deform(vertex.size(), dvector1D(3,0.0));
	freeContainer(result);
	result.resize(coord.size(), dvector1D(3,0.0));
	 
	// setting dimensions of lattice for internal use of the function
	for(int intv=0; intv<3; intv++) n_lattice[intv] =  lattice.n[intv];

	// setting dimensions of structures
	n_lattice_tot =  lattice.n_points;
	n_points= lattice.puntSelection->mapMotherV.size() ;

	allowDisp.resize(n_points,0.0);
	allowSupp.resize(n_points,0);
	mapCollision.resize(n_points,-1);

	for(int i_px = 0; i_px < n_points; i_px++)       // counting on shape points selected
	{
		int i_p = lattice.puntSelection->mapMotherV[i_px];

		val = lattice.NurbsEvaluator(coord[i_p]);
		vinculate = FFD_Ext::constraint(i_px, lattice);

		if(deformability != NULL) (*deformability)[i_p] = vinculate;
		deform[i_p] = vinculate*val;

		//now check collisions if available
		if(controlType != NULL)
		{
			//check tolerance

			if(controlTol!=NULL) {tolerance = *controlTol;}

			//allocate back-support structure
			double disp;
			int tri;

			// prepare TRIANGLE_INTERSECTIONS
			insectK.puntOriginal = Oshape;
			insectK.puntConstraint= Cshape;


			// convert your fresh deformation in the original s.d.r
			dvector1D direction(3,0); direction = deform[i_p];


			bool checkColl = collision_WConstr(&insectK, i_p, Oshape->InverseSimplexMap[i_p][0],
												direction,disp, tri);

			if(checkColl)
			{
				allowDisp[globCounterCollision]=disp;
				allowSupp[globCounterCollision]=tri;
				mapCollision[globCounterCollision]=i_p;
				globCounterCollision++;
			}

		}//end if check on collision
	} // next i_p - cycling on the point of SupportMesh triangulation

	//specialize your control tecnique, according to the collision control type you selected

	allowDisp.resize(globCounterCollision);
	allowSupp.resize(globCounterCollision);
	mapCollision.resize(globCounterCollision);

	dvector1D xOR, updDef, interval;
	//now check if whole field control is active
	if(controlType != NULL && *controlType==0)
	{
		std::cout<<"Found  "<<globCounterCollision<<" possible collision in your scene. Going to cure it w/ a whole field control tech."<<'\n';

		int posix;

		wConstr0_WholeBody(allowDisp,allowSupp,mapCollision,Cshape, deform, posix);

		double vInterp, sign,diff,rescale;
		updDef = deform[mapCollision[posix]];
		interval = updDef;
		bool checkLS = true;

		int esc=0;
		while (checkLS){ //iteratively check max displacement with respect to constraint levelset
			xOR = vertex[mapCollision[posix]]+updDef;
			Bmesh->interpolatePointData(xOR,Cdistance,vInterp);
			diff=tolerance-vInterp;

			if( abs(diff)/tolerance < 1.0e-8 || esc>1000){ checkLS = false;}
			else {
					sign=getSign(diff);
					interval=interval/2.0;
					updDef=updDef-sign*interval;
					++esc;
			}
		}
		rescale=norm_2(updDef)/norm_2(deform[mapCollision[posix]]);
		std::cout<<"Rescaling factor for whole_constr method :  "<< rescale << endl;
		result=deform*rescale+coord;

		std::cout<<"Reducing displacements done"<<'\n';
	}

	//now check if fit constraint body control is active
	if(controlType != NULL && *controlType==1)
	{
		std::cout<<"Found  "<<globCounterCollision<<" possible collision in your scene. Going to cure it w/ a fit constraint body control tech."<<'\n';

		ivector1D posix;

		wConstr1_FitBody(allowDisp,mapCollision,deform);

		double vInterp, sign, diff;
		for(int i=0; i<globCounterCollision; ++i){
			xOR = vertex[mapCollision[i]]+deform[mapCollision[i]];
			Bmesh->interpolatePointData(xOR,Cdistance,vInterp);

			if(tolerance>=vInterp) posix.push_back(i);

		}

		int nposix=posix.size();

		for(int i=0; i<nposix; ++i){

			updDef = deform[mapCollision[posix[i]]];
			interval = updDef;
			bool checkLS = true;
			int esc=0;

			while (checkLS){ //iteratively check each displacement with respect to constraint levelset
				xOR = vertex[mapCollision[posix[i]]]+updDef;
				Bmesh->interpolatePointData(xOR,Cdistance,vInterp);
				diff=tolerance-vInterp;

				if( abs(diff)/tolerance < 1.0e-8 || esc>1000) checkLS = false;
				else {
					sign=getSign(diff);
					interval=interval/2.0;
					updDef=updDef-sign*interval;
					++esc;
				}
			}
			deform[mapCollision[posix[i]]]=updDef;

		}

		result = deform + coord;
		//deform = lattice.remapORToLattice(deform_temp);

		std::cout<<"Reducing displacements done"<<'\n';

	}//endif *controlType=1


} //................ end of function deformation





template <int Dim> void FFD_Ext::BernCast(int n, std::vector < std::vector <double> > & ld, double coord, std::vector<double> & valTarget) 
{
	/* ============================================================================================================ !
 double BernCast(n,ld,coord, vector of results valTarget) 								                  	!
														!
 Evaluate the local deformation in coord within[0,1], given an array of deformative loads (n+1,Dim) on lattice  !
 by means of De Casteljau algorithm                            							!
 ============================================================================================================== !
 I/O stats													!
 ============================================================================================================== !
 - n : integer                                                                                                  ! 
 - ld : double matrix [n+1][Dim] of deformative loads in direction of coord                                     !
 - double coord : evaluation point coordinate			            					!
 - RETURNING std::vector<double> value: double,evaluate the Bernstein function of order (n,p) in xx,            !
                                        and returns deformation in vector of size Dim             		!
 ============================================================================================================== !
Dependencies												        !
 ============================================================================================================== !
 - none                                                                                                         !
! ============================================================================================================= !
!! DECLARE VARIABLES												!
! ============================================================================================================= */

	// I/O stats
	std:: vector<double> value (Dim,0.0e0);

	//  Workspace
	int k1,k2, k3;

	//COMPUTE THE Bernstein function (n,p) value  in the point xx, under the array of n deformative loads ld,
	//via De Casteljau algorithm

	for (k1=n-1; k1>=0; k1--) //recursive loop on number of loads
	{
		for(k2=0; k2<=k1; k2++)
		{

			for (k3=0; k3<Dim; k3++) //internal loop for vector elements
				ld[k2][k3] = (1.0e0 - coord) * ld[k2][k3] + coord * ld[k2+1][k3] ;

		}//next k2
	}//next k1

	for(k3=0;k3<Dim;k3++)  value[k3] = ld[0][k3];

	valTarget.swap(value);

} //end of function BernCast



//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

// end of libRA_FFD.tpp

 




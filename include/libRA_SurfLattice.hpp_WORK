//TODO need to be updated to BSpline and New Base-Derived Paradigm.


#ifndef _LIB_SURFLATTICE_
#define _LIB_SURFLATTICE_

// main of 3D morpher based on  Free Form Deformation

#include "libRA_Lattice.hpp"
#include "CG_Basics.hpp"
#include <array>
using namespace std;



/*! Defines a 2D cartesian grid (rectangular shape) of control nodes based on a bivariant map calculated on the original geometry, and it is
 * responsible of the shape deformation. Displacements of such control nodes are directly linked to displacements of 
 * all the vertex of the original tasselation, by means of a standard Bezier superficial parametrization.
 * Each Lattice structure applies deformation, on a portion of the original tasselation, strictly contained in the lattice box, 
 * and that need to be specified by the User.
 *
 */

class VTK_SURFLATTICE: public VTK_UnstructuredGrid<VTK_SURFLATTICE>
{
protected:
	dvector2D * points;
	ivector2D * connectivity;
public:
	VTK_SURFLATTICE();
	VTK_SURFLATTICE(std::string dir_, std::string name_, std::string cod_, int nP_, int nC_, int nConn_);
	~VTK_SURFLATTICE();

	void linkData(dvector2D &, ivector2D & );
	void unlinkData();
	void Flush(  fstream &str, string codex_, string name  ) ; //CRTP
	//	    void Absorb(  fstream &str, string codex_, string name  ) ; //CRTP
};

class SURFLATTICE {
public:
	// members

	std::string name;				/*!< string. Name of the lattice, assigned by the user */
	std::string loadfile;           /*! file of displacement of the lattice nodes */
	int n_points;                     /*!<  Integer. Total number of nodes defined in the Lattice */

	int n[3];                       /*!<  Integer, Array[Dim]. Number of nodes in each direction of the space (x,y) for Dim=2,
							    (x,y,z) for Dim=3. Given a i direction, and N the number of effective nodes prescribed for that 
							    direction,  n[i] is defined as: n[i] = N -1 */

	lattice_pt<3> * points;    /*!<  Array of lattice_pt_surf. Allocatable structure of the Lattice's nodes */
	ivector1D 	    nodalSupportTriangle;  /*!< list of support triangle on puntSelection triangulation of each node lattices */

	double transition;		      /*!<  Double. Parameter, defined in [0,1], set the transition zone between
							    selected deformable and undeformable zones of geometry. If =0, no transition
							    is applied, if =1 all the selected region is used as a transition zone.*/

	ivector1D boundary;      /*!<  Integer. Boundary condition at the segmented frontier between the selected deformable zone
							     of the geometry and the undeformable zone. Four types of b.c.'s can be 
							     prescribed, according to the type of integer variable feeded: 

									-->  0 - free boundary. No continuity enforced.

									-->  1 -  enforced a C0 continuity

									-->  2 -  enforced a C1 continuity

									-->  3 -  enforced a C2 continuity */

	dvector1D seedPointBoundary; /*!< Seeding point for boundary segmentation */
	svector1D geo_segmented; 	 /*!< list of nighboring geometry files for boundary patch segmentation */
	int RefineSupport; /*!< Integer. Flag to activate the Red/Green Refinement on the selected deformable geometry.
							   If =0, no Refinement is provided, if =1 Refinement becomes active.*/

	std::string mode;  /*!< std::string. Define the way to select the deformable support associated to the Lattice,
							   on the original tasselation. Three choices are possible:

								2)		BYPATCHES choice: selecting/unselecting portions of triangulation contained in Hexaedrical patches draw by the User or
											  	  	  	  marked by some identifier PID's (only for *.nas superficial meshes)

								3)      BYFILE choice:	reading the Id of each triangular Simplex that build the deformable support selection, directly from an external file */

	std::string file_external;        /*!< std::string. Name of the external file, containing the deformable support selection. See LATTICE<*,*>::mode, BYFILE choice   */
	std::string file_patch;           /*!< std::string. Name of the external file, containing those information about selecting/unselecting patches and PID markers, necessary
									to build the defromable support selection. See SURFLATTICE::mode, BYPATCHES choice   */

	dvecarr3E mapCoord;           /*! mapped coordinate in the real 3D-space. */								
	ParaSurfMesh * puntSelection;

	/*! Class Constructor. Symply resizing the class members LATTICE<*,*>::origin and LATTICE<*,*>::span_lattice to the Dim value */
	SURFLATTICE();

	/*! Class Destructor. */
	virtual ~SURFLATTICE();

	SURFLATTICE(const SURFLATTICE &);

	SURFLATTICE & operator=(const SURFLATTICE &);

	/*!Write the Lattice mesh in an hexaedrical grid, in *.vtu format for ParaView. In input, it requires the definition, respectively, of:
	 *
	 * 	1) std::string & --> name of the folder where the grid file will be stored
	 *
	 * 	2) std::string   --> name of the grid file
	 *
	 *  3) int --> set counter for your file
	 *
	 *	4)bool --> select writing ascii/binary
	 *
	 * 	5) bool	--> select writing the deformed Lattice grid (true) or the undeformed one(false)   */
	void plot_gridVTU(std::string &, std::string , int, bool, bool ) ;

	/*!Write the Lattice mesh in an point cloud, in *.vtu format for ParaView. In input, it requires the definition, respectively, of:
	 *
	 * 	1) std::string & --> name of the folder where the grid file will be stored
	 *
	 * 	2) std::string   --> name of the point cloud file
	 *
	 *	3) int --> set counter for your file
	 *
	 *	4)bool --> select writing ascii/binary
	 *
	 * 	5) dvector2D --> 3D points list.   */
	void plot_cloudVTU( std::string & , std::string, int , bool ,  dvector2D & );

	/*! Build the Lattice, the mesh of control nodes and set its parameters. It references to private method of the class:
	 *
	 * 		- LATTICE<*,*>::define_lattice_mesh_equi()
	 *
	 * 		- LATTICE<*,*>::set_lattice()
	 *
	 * In input,it requires the reference to the class SHAPE, containing the information of the original geometry and an integer variables
	 * that identifies the lattice --> see ControlDeformation class.			 */
	void build_lattice();

	/*! Set an equispaced grid of control nodes on the lattice domain, and save their position in the  LATTICE<*,*>::points->coord */
	void define_lattice_mesh_equi();

	/*! get bounding box of the selection associated to the lattice, and return origin and 3D span of the box to Lattice members */
	void getBoundingBoxSelection(dvector1D &, dvector1D &);

	/*! write template for Lattice nodal displacements file. If flag its true move Node according to the normal of nodal support Triangle on triangulation */
	void writeLoadTemplate(bool flag);
	/*! read displacements of the LAttice's node from file */
	void readLoadFile();

	/*! link a bivariant ParaSurfMesh to the lattice and calculate grid node position on the real map */
	void linkSelection(ParaSurfMesh &);

	/*! Return real world lattice coordinate in dvector2D for visualization purposes. Flag true/false print deformed/original coordinates */
	dvector2D getCoordLattice(bool flag);

	void extract_simplex(ivector1D &source, int &who,ivector1D &tasselationSimplex);

	dvector2D getRBF(ivector1D &, dvector2D &, double &);

	double getArea3D(dvector1D &, dvector1D &, dvector1D &);
	double getArea2D(dvector1D &, dvector1D &, dvector1D &);

	bool point2DBelongsTriangle(dvector1D &, dvector1D &, dvector1D &, dvector1D &);

	dvector1D mapPonTriangle(ivector1D &, dvector1D &);

};//end of class surflattice

#endif  


// =================================================================================== //
// INCLUDES                                                                            //
// =================================================================================== //
# include "LevelSet_Geometry.hpp"


double eikonal::triangulation::Eikonal2DTriUpdate( Class_SurfTri *     tri,  //reference mesh
												  dvector1D            &val,// scalar field to be propagated
                             		          	  double                g,   // propagation direction
                             		          	  double                s,   // propagation speed
                             		          	  int                   Itarget,   // index of working node
                             		          	  int 					Ttarget,   // triangle index which the target node belongs to
                             		          	  vector<short>        &flag)  // flag for dead/alive/far-away

{//update SDF on target node by solving the Eikonal eq
 // Update scalar field value at mesh cell I of a  traingulate mesh for the 2D Eikonal 
 // equation.                                                                          
 // - val      : dvector1D, scalar field to be marched                                  //
 // - grad     : dvector2D gradient 
 // - g        : double, propagation speed of the Eikonal equation                      //
 // - s        : double, flag for inwards/outwards propagation (s = -+1)                //
 // - I        : int, global index of the cell to be updated                            //
 // - flag     : vector<short>, with flag for dead vertex (flag = 0), alive vertexes    //
 //              (flag = 1), and far away vertexes (flag = 2).                          //

// Parameters
double const           pi = atan(1.0)*4.0;
int		      		   dim = tri->Vertex[0].size();
        
// =================================================================================== //
// UPDATE THE LOCAL VALUE OF THE SCALAR FIELD.                                         //
// =================================================================================== //

// Local variables
bool                   check;
int                    select = -1;
double                 value = 1.0e+18;
double                 a, b, c, A, B, C, K, discr ;
double 		       	   xi1, xi2, phi_U, phi_W, phi_P, tmp_value1, tmp_value2;
double 		       	   dWU, dVW, dVU, dVP;
dvector1D              eWU(dim,0.0),eVW(dim,0.0), eVP(dim,0.0),eVU(dim,0.0), P(dim,0.0);
	
// Counters
int                    j, k, m,n;
int                    I;
int                    U, V, W;

// =================================================================================== //
// UPDATE THE LOCAL VALUE OF THE SCALAR FIELD.                                         //
// =================================================================================== //

// Vertex global index --------------------------------------------------------------- //
V = Itarget;
bool checkRing;
ivector1D AdjacencyVT = tri->Ring_1(Ttarget, tri->vertex(Ttarget,Itarget), checkRing);
value = abs(val[V]);

// Loop over simplex in the 1-Ring --------------------------------------------------- //
for (j = 0; j < AdjacencyVT.size(); ++j) {

	 // Triangle data
         I = AdjacencyVT[j];
         k = tri->vertex(I, V);
         k = (k + 1) % tri->Simplex[I].size();
         U = tri->Simplex[I][k];
         m = (k + 1) % tri->Simplex[I].size();
         W = tri->Simplex[I][m];

   if ((flag[U] == 0) && (flag[W] == 0)) {
                select = 2;
      }
   else {
          if ((flag[U] == 0) || (flag[W] == 0)) {
                   select = 1;
                   if (flag[W] == 0) {
                       U = W;
                   }
               }
	  else {
	       select = 0;
	       }
       }

// Compute solution to the 2D Eikonal equation with 1 dead node ------------------ //
 if (select == 1) {

      // Compute level set value
      eVU = conVect(tri->Vertex[V] - tri->Vertex[U]);
      dVU = norm_2(eVU);
      value = min(value, abs(val[U]) + g*dVU);

      }

// Compute solution to the 2D Eikonal equation with 2 dead nodes ----------------- //
 else if (select == 2) {

      // Geometrical data ---------------------------------------------------------- //
      eVW = conVect(tri->Vertex[V] - tri->Vertex[W]);
      dVW = norm_2(eVW);
      eVW = eVW/dVW;
      eVU = conVect(tri->Vertex[V] - tri->Vertex[U]);
      dVU = norm_2(eVU);
      eVU = eVU/dVU;
      eWU = conVect(tri->Vertex[W] -tri->Vertex[U]);
      dWU = norm_2(eWU);
      eWU = eWU/dWU;

      // Coeffs -------------------------------------------------------------------- //
      K = abs(val[W]) - abs(val[U]);
      a = pow(dWU, 2);
      b = -dWU*dVU*Dot_Product(eWU, eVU);
      c = pow(dVU, 2);
      A = a*(pow(K, 2) - a);
      B = b*(pow(K, 2) - a);
      C = (pow(K, 2)*c - pow(b, 2));
      discr = pow(B, 2) - A*C;
      phi_U = abs(val[U]);
      phi_W = abs(val[W]);

      // Find optimal solution ----------------------------------------------------- //

      // case #1: no solution
      if (discr < -1.0e-12) {
                goto label_10;
                }
      discr = abs(discr);

      // case #2: 2 distinct solutions
      if (abs(A) > 1.0e-12) {

            // Solutions
            xi1 = (-B - sqrt(discr))/A;
            xi2 = (-B + sqrt(discr))/A;

           // Restriction of solutions onto [0, 1]
            xi1 = min(1.0, max(0.0, xi1));
            xi2 = min(1.0, max(0.0, xi2));

            // Solution #1
            P = (1.0 - xi1)*conVect(tri->Vertex[U]) + xi1*conVect(tri->Vertex[W]);
            eVP = conVect(tri->Vertex[V]) - P;
            dVP = norm_2(eVP);
            eVP = eVP/dVP;
            phi_P = (1.0 - xi1)*phi_U + xi1*phi_W;
            tmp_value1 = phi_P + g*dVP;

            // Solution #2
            P = (1.0 - xi2)*conVect(tri->Vertex[U]) + xi2*conVect(tri->Vertex[W]);
            eVP = conVect(tri->Vertex[V]) - P;
            dVP = norm_2(eVP);
            eVP = eVP/dVP;
            phi_P = (1.0 - xi2)*phi_U + xi2*phi_W;
            tmp_value2 = phi_P + g*dVP;
           }

            // case #3: 2 coincident solutions
            else if ((abs(A) < 1.0e-12) && (abs(A) >= 0.0)) {

             // Solution #1
             P = conVect(tri->Vertex[U]);
             eVP = conVect(tri->Vertex[V]) - P;
             dVP = norm_2(eVP);
             eVP = eVP/dVP;
             phi_P = phi_U;
             tmp_value1 = phi_P + g*dVP;

             // Solution #2
             P = conVect(tri->Vertex[W]);
             eVP = conVect(tri->Vertex[V]) - P;
             dVP = norm_2(eVP);
             eVP = eVP/dVP;
             phi_P = phi_W;
             tmp_value2 = phi_P + g*dVP;
            }

            // Update solution ----------------------------------------------------------- //
            value = min(value, min(tmp_value1, tmp_value2));
            }
label_10:
            continue;

} //next j

return(value);

}; //end of Eikonal2DTriUpdate
//=---------------------------------------------------------------------------------------------------------//

void eikonal::triangulation::Eikonal2DTriSolve(Class_SurfTri 	* tri, // triangulated mesh
											   ivector2D	    * inverseConnectivity,//inverse connectivity of your mesh
											   dvector1D         &val,   // scalar field to be propagated
											   dvector2D	    &grad, // gradient???
											   double               g,   // propagation speed
											   double               s)  // propagation direction
		
{//calculate SDF on the patch triangulation
 // Solve the Eikonal equation |grad(u)| = g, using  a fast marching method over a      //
 // triangular mesh.(Function in the unknown region must be initialized to the value    //
 // 1.0e+18)                                                                            //
 // - AdjacencyVV: vertex-vertex map of negihbors                                       //
 // - val       : dvector1D, with function values at mesh vertexes.                     //
 // - grad      : dvector2D, gradient on vertexes					//
 // - g         : double, slowness for the Eikonal equation.                            //
 // - s         : double, velocity sign (+1 --> propagate outwards, -1 --> propagate    //
 //               inwards)                                                              //
        
       // Local variables
        bool                     check;
        int                      n_list;
        double                   value;
        int            	         index;
        ivector2D                *map_ = NULL, map;
        vector<short>            flag;

        // Counters
        int                      i, j;
        int                      V,V1;
        int                      T;

        // =================================================================================== //
        // FLAG DEAD/ALIVE/FAR-AWAY VERTICES                                                   //
        // =================================================================================== //

        // Initialize data structure --------------------------------------------------------- //
        flag.resize(tri->nVertex, (short) 2);

        // Loop over simplex ----------------------------------------------------------------- //
        for (V = 0; V < tri->nVertex; ++V) {

                // Dead vertices
                if (abs(val[V]) < 1.0e+18) {
                    if (s*val[V] >= 0.0) {
                        flag[V] = 0;
                    }
                    else {
                       flag[V] = -1;
                    }
                }
            } //next V
        // =================================================================================== //
        // BUILD MIN-HEAP                                                                      //
        // =================================================================================== //

        // Initialize heap data structure ---------------------------------------------------- //
        n_list = count(flag.begin(), flag.end(), 0);
        map.resize(tri->nVertex, ivector1D (2, -1));
        map_ = &map;

	minPQUEUE<double, int> heap(n_list, true, map_);

	// Insert dead vertices in heap ------------------------------------------------------ //
        j = 0;
        for (V = 0; V < tri->nVertex; V++) {

                // Insert data in min-heap
                if ((flag[V] == 0) && (map[V][1] == -1)) {

                    // Value
                    heap.keys[j] = s*val[V];

                    // Data
                    heap.labels[j] = V;
                   
                    // Map
                    map[j][0] = V;
                    map[V][1] = j;

                    // Update counter
                    j++;

                } //endif
            } //next V
        
        // Build heap ------------------------------------------------------------------------ //
	
	heap.heap_size = j;		
	heap.build_heap();

        // =================================================================================== //
        // FAST MARCHING                                                                       //
        // =================================================================================== //
        while (heap.heap_size > 0) {

                // Extract root from min-heap
                heap.extract(value, index);

                // Update level set value
                V = index;
                val[V] = value;

                // Update flag
                flag[V] = (short) 0;

             int T = (*inverseConnectivity)[V][0];
             int locj= tri->vertex(T,V);

             bool check;
             ivector2D ring_Vertex = tri->VRing_1(T,locj, check);

            ivector1D AdjacencyVV(ring_Vertex.size(),-1);

            for(int counter=0; counter<ring_Vertex.size(); ++counter){
            	AdjacencyVV[counter] = tri->Simplex[ring_Vertex[counter][0]][ring_Vertex[counter][1]];
            }

            // Update neighboors in the 1-ring of vertices ---------------------------------- //
            for (i = 0; i < AdjacencyVV.size(); ++i) {
                V1 = AdjacencyVV[i];
                if (flag[V1] == (short) 1) {

                    // Update the local value
		    value = s * eikonal::triangulation::Eikonal2DTriUpdate( tri, val, s, g, V1, (*inverseConnectivity)[V1][0], flag);
                    val[V1] = value;
		    	    // Update value in min-heap
                    heap.modify(map[V1][1], value, V1);
                }
                else if (flag[V1] == (short) 2) {

                    // Update the local value
                	value = s* eikonal::triangulation::Eikonal2DTriUpdate( tri, val, s, g, V1, (*inverseConnectivity)[V1][0], flag);
                    val[V1] = value;
                    // Update flag
                    flag[V1] = (short) 1;

                    // Insert neighbor into the min heap
                    map[heap.heap_size][0] = V1;
                    map[V1][1] = heap.heap_size;
                    heap.insert(value, V1);
                }
            } //next i

        } //next item

        // =================================================================================== //
        // INVALIDATA POINTERS                                                                 //
        // =================================================================================== //
        map_ = NULL;

        return; 
	}; //end of Eikona2DTriSolve



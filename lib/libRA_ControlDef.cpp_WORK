#include "libRA_ControlDef.hpp"

ControlDeformation::ControlDeformation (std::string input_lattice, std::string inputFolder)
{ // read the input of lattices from file and set the vector of lattices.

	nLattices = 0;
	adaptivity_level = 0;
	input_folder = inputFolder;
	// workspace
	ifstream reading;
	int  jdir, kcount;
	std::string line, direction, otype;
	std::vector<int> ii(3,0), nn(3,0);
	double value;

	// open file input_lattice and check the result
	reading.open(input_lattice.c_str());

	if (reading.is_open())   // check: successfully opened, proceed
	{

		readNumberLattices(reading);

		readAdaptLevel(reading, inputFolder);

		for(int kLat = 0; kLat<nLattices; kLat++)
		{

			morphLattices[kLat].name = readLatticeName(reading);

			morphLattices[kLat].RefineSupport=(int)readRefineFlag(reading);

			morphLattices[kLat].wholeLattice=readWholeFlag(reading);

			bool checkLS = readLevelSetInfo(reading,morphLattices[kLat].levelset, morphLattices[kLat].heatTime);
			if(checkLS){std::cout<<"WARNING! mispelled levelset method for lattice :"<<kLat<<" . Reset to default values!"<<endl;}


			std::string fileMode;
			readSelectionMode(reading, inputFolder, morphLattices[kLat].mode, fileMode);


			if(morphLattices[kLat].mode == "BYPATCHES") {morphLattices[kLat].file_patch=fileMode;}
			else										{morphLattices[kLat].file_external=fileMode;}

			ivector1D ndim = readLatticeDim(reading,morphLattices[kLat].origin, morphLattices[kLat].span_lattice);
			
			
			morphLattices[kLat].setLatticeDimension(ndim[0]+1, ndim[1]+1, ndim[2]+1, ndim[3], ndim[4], ndim[5]);
			
			ivector1D bcs;
			svector1D ngeos;
			dvector1D seed(3,0.0);
			bvector1D checkBC=readBoundaryConditions(reading,inputFolder, bcs,morphLattices[kLat].transition,seed, ngeos);


			//check immediately
			if(checkBC[0]){
				std::cout<<"WARNING! Some mispelled BC strings found. CAMILO reset them to default values C2."<<endl;
			}

			if(checkBC[1]){
				std::cout<<"ERROR! defining Neighbors geometries or autosegmentation for multi BC definition. Some files does not exists or are corrupted."<<endl;
				std::cout<<"Check them in the designed Input folder. For now exit CAMILO!"<<endl;
				exit(1);
			}

			int size = bcs.size();

			if(size == 2){
				morphLattices[kLat].boundary = bcs[0];
				morphLattices[kLat].boundary_int = bcs[1];
			}
			if(size == 4){
				morphLattices[kLat].bc_segmented.resize(size,0);
				morphLattices[kLat].bc_segmented= bcs;

				morphLattices[kLat].geo_segmented.resize(size,"");
				morphLattices[kLat].geo_segmented = ngeos;

				if(ngeos[0].empty()){
				morphLattices[kLat].seed.resize(3,0);
				morphLattices[kLat].seed= seed;
				}
			}


			morphLattices[kLat].loadfile = readLoadFileInfo(reading, inputFolder);

			readEndLattice(reading);

		}// end of loop on lattices

	} // end of if reading

	else{std::cout<<"WARNING! cannot find the file for Reading the Lattice config "<<input_lattice << " in folder Input.Please check"<<endl;exit(1);}
	reading.close();
} // end of CONSTRUCTOR
ControlDeformation::~ControlDeformation()
{

}

void ControlDeformation::readNumberLattices(ifstream & input)
{
	std::string line, otype;
	int countRead = 0;

	do{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$NLATTICES" );

	//READING NUMBER OF LATTICES IN THE SCENE
	std::stringstream s1;
	s1.str(trim(line));
	s1 >> otype >> nLattices;
	morphLattices.resize(nLattices);

};
void ControlDeformation::readAdaptLevel(ifstream & input, std::string &folder)
{
	std::string line, otype;

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$ADAPTIVITY_LEVEL");

	std::stringstream s1;
	s1.str(trim(line));
	s1 >> otype >> adaptivity_level;

	fileAdaptivity.resize(adaptivity_level,"");

	int countFile = 0;

	do{
		std::stringstream ss;
		std::getline(input,line);
		ss.str(trim(line));
		ss >> otype;
		std::string dummy;
		// start reading the loads
		if(otype =="$FILE")
		{
			ss >>dummy;
			fileAdaptivity[countFile] = folder+"/"+dummy;
			countFile++;
		}
	}while((otype != "$ENDADAPTIVITY") && (countFile< adaptivity_level));

	//check errors
	if(countFile <adaptivity_level)
	{
		std::cout<<"Not enough files of adaptation to perform the required level!"<<'\n';
		std::cout<<"program will now exit....."<<'\n';
		exit(1);
	}

	adaptivityList.resize(adaptivity_level);



};
std::string ControlDeformation::readLatticeName(ifstream & input)
{
	std::string result, line,otype;
	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$LATTICE");

	std::stringstream s0;
	s0.str(trim(line));
	s0>>otype>>result;
	return(result);
};
bool ControlDeformation::readRefineFlag(ifstream & input)
{
	bool result=false;
	std::string line, otype;
	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$REFINE");

	//READING if MUST be REFINE SUPPORT IN THE SCENE

	std::stringstream s1;
	s1.str(trim(line));
	int checkRefine;
	s1>>otype>>checkRefine;
	if(checkRefine > 0) {result=true;}
	return(result);
};
bool ControlDeformation::readWholeFlag(ifstream & input)
{
	bool flag=false;
	std::string line, otype;

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$WHOLE");

	//READING if whole or decimated control nodes in lattice

	std::stringstream s1;
	s1.str(trim(line));
	int checkwhole;
	s1>>otype>>checkwhole;
	if(checkwhole >0 ){flag = true;}

	return(flag);
};
bool ControlDeformation::readLevelSetInfo(ifstream & input, std::string &result, double & heatTime)
{
	bool err=false;
	std::string line, otype;

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$LEVELSET");

	//READING The Method to calculate the level set on the lattice associated support

	std::stringstream s0;
	s0.str(trim(line));
	s0>>otype>> result;

	result=trim(result);

	if(result !="DEFAULT" && result!="HEAT" && result!="GEODESIC"){
		//Checked mispelling
		result = "DEFAULT";
		err=true;
	}

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$TIME");

	//READING The time lapse for Heat propagation on the support

	std::stringstream s1;
	s1.str(trim(line));
	s1>>otype>>heatTime;

	if(heatTime < 1 || std::isnan(heatTime) ){
		heatTime = 1;
	}

	return(err);
};
void ControlDeformation::readSelectionMode(ifstream & input, std::string & folder, std::string &method, std::string &file)
{
	std::string line, otype, append;

	do
	{
		std::getline(input, line);
		std::stringstream ss;
		ss.str(trim(line));
		ss>>otype;
	} while(otype !="$MODE");


	//READING THE MODE FOR TASSELATION SELECTION
	std::stringstream s0;
	s0.str(trim(line));
	s0 >> otype >> method ;

	//check for mispelling in mode keyword

	if((method != "BYPATCHES") && (method != "BYFILE")) {method="DEFAULT";}


	do
	{
		std::getline(input, line);
		std::stringstream ss;
		ss.str(trim(line));
		ss>>otype;
	} while(otype !="$FILENAME");


	//READING THE RIGHT FILENAME FOR TASSELATION SELECTION
	std::stringstream s1;
	s1.str(trim(line));

		s1 >> otype >> append;
		file =folder+"/"+append;

		if(method == "DEFAULT")   file="";

};
ivector1D ControlDeformation::readLatticeDim(ifstream & input, dvector1D & origin, dvector1D & span)
{
	ivector1D ndim(6,0);
	std::string line,otype;
	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$ORIGIN");

	//READING THE ORIGIN POINT OF THE LOCAL SDR LATTICE
	std::stringstream s0;
	s0.str(trim(line));
	s0 >> otype;
	for(int i=0; i<3; i++) s0 >> origin[i];


	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$SPAN");

	//READING THE 3 DIMENSION OF LATTICE PRISM
	std::stringstream s1;
	s1.str(trim(line));
	s1 >> otype;
	for(int i=0; i<3; i++) s1 >> span[i];

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$DIMENSION");

	//READING THE DOF NUMBERS OF LATTICE, IN EACH DIRECTION
	std::stringstream s2;
	s2.str(trim(line));
	s2 >> otype;
    s2 >> ndim[0]>>ndim[1]>>ndim[2];
  
	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$CURVEDEGREE");

	//READING THE DOF NUMBERS OF LATTICE, IN EACH DIRECTION
	std::stringstream s3;
	s3.str(trim(line));
	s3 >> otype;
	s3 >> ndim[3]>>ndim[4]>>ndim[5];
    
	return(ndim);

};
bvector1D ControlDeformation::readBoundaryConditions(ifstream & input, std::string & folder, ivector1D & bcs,  double & transition, dvector1D & seed, svector1D & neigh_geos)
{
	bvector1D check(2, false);
	bool flagtype;
	std::string line, otype, bctype;
	svector1D bcstr;
	neigh_geos.resize(4,"");
	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$BCS_TYPE");

	//READING THE BCS TYPE MAP, FOR EACH LATTICE kLat FACE
	std::stringstream s0;
	s0.str(trim(line));
	s0 >> otype >> bctype;

	if(bctype == "SEGMENTED"){flagtype=true;  bcs.resize(4,0); bcstr.resize(4,"");}
	else 					 {flagtype=false; bcs.resize(2,0); bcstr.resize(2,"");}


	do{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
		} while(otype != "$BCS");


	if(!flagtype){
		std::stringstream s1;
		s1.str(trim(line));
		s1 >> otype >> bcstr[0] >>bcstr[1];

		for(int i=0; i<2; ++i){
			bcs[i]=(bcstr[i]=="F") + (bcstr[i]=="C0")*2 + (bcstr[i]=="C1")*3 + (bcstr[i]=="C2")*4 -1;
			if (bcs[i] == -1)
			{
				check[0]=true;
				//snooze to default -->
				bcs[i]=3;
			}
		}

		//reading transition
		do
		{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
		} while(otype != "$TRANSITION" && otype !="$ENDLATTICE");

		if(otype == "$ENDLATTICE")
		{
			std::cout<<"Error reading Lattice input. Missing $TRANSITION value. Exiting"<<endl;
			exit(1);

		}

		//READING THE transition of geodesic filter
		std::stringstream s2;
		s2.str(trim(line));
		s2 >> otype >> transition;

		//check immediatly
		if(transition<0.0 || transition > 1.0){transition = 1.0;}
	}
	// check for multibc version

	if(flagtype){

		std::stringstream s1;
		s1.str(trim(line));
		s1 >> otype >> bcstr[0] >>bcstr[1]>>bcstr[2]>>bcstr[3];

		for(int i=0; i<4; ++i){
			bcs[i]=(bcstr[i]=="F") + (bcstr[i]=="C0")*2 + (bcstr[i]=="C1")*3 + (bcstr[i]=="C2")*4 -1;
			if (bcs[i] == -1)
			{
				check[0]=true;
				//snooze to default -->
				bcs[i]=3;
			}
		}

		//find first of BYNEIGHS and SEED methods
		do
		{
			std::getline(input,line);
			std::stringstream ss;
			ss.str(trim(line));
			ss >> otype;
		} while(otype != "$BYNEIGHS" && otype != "$SEED" && otype != "$ENDLATTICE");

		if(otype == "$ENDLATTICE")
		  {
			std::cout<<"Error reading Lattice input. Missing $BYNEIGHS or $SEED value. Exiting"<<endl;
			exit(1);
			}


		if(otype == "$BYNEIGHS"){
			//READING THE transition of geodesic filter
			std::stringstream s2;
			s2.str(trim(line));
			s2 >> otype >> neigh_geos[0]>> neigh_geos[1]>> neigh_geos[2]>> neigh_geos[3];

			//check immediatly
			for(int k=0; k<4; ++k){

				check[1]= check[1] || (neigh_geos[k].empty());
				std::stringstream ss;
				ss<<folder<<"/"<<neigh_geos[k];
				neigh_geos[k]=ss.str();

				ifstream checkRead;
				checkRead.open(neigh_geos[k].c_str());
				check[1]= check[1] || (!checkRead.is_open());

				if(checkRead.is_open()){checkRead.close();}
			}
		}

		if(otype == "$SEED"){
			//READING THE transition of geodesic filter
			std::stringstream s2;
			s2.str(trim(line));
			s2 >> otype >> seed[0]>> seed[1]>> seed[2];

			double norm = norm_2(seed);
			if(std::isnan(norm)){check[1]=true;}

		}

	}

return(check);

};
std::string ControlDeformation::readLoadFileInfo(ifstream & input, std::string & folder)
{
	std::string loadfile, line, otype;

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$FILELOAD");

	//READING THE file name of lattice loads
	std::stringstream s0,s1;
	std::string loaddummy;
	s0.str(trim(line));
	s0 >> otype >> loaddummy;

	s1<<folder<<"/"<<loaddummy;

	loadfile= s1.str();
	return (loadfile);
};
void ControlDeformation::readEndLattice(ifstream & input)
{
	std::string line, otype;
	do{
		std::stringstream ss;

		std::getline(input,line);
		ss.str(trim(line));
		ss >> otype;
	} while(otype !="$ENDLATTICE");

};


void ControlDeformation::setAdaptivity()
{
	//read the adaptivity files and set the respective adaptive_lattice structure.

	bool check = checkOrderingAdaptivityFile();
	if(!check)
	{
		std::cout<<"Errors occured in the definition of adaptivity hierarchy.Recheck your files!"<<'\n';
		std::cout<<"Exiting...."<<'\n';
		exit(1);
	}

	for(int i=0; i<adaptivityList.size(); i++)
	{
		readAdaptivityFile(fileAdaptivity[i]);
	}

}//end of set adaptivity

bool ControlDeformation::checkOrderingAdaptivityFile()
{
	bool check = false;
	ivector1D remap;
	remap.resize(fileAdaptivity.size(),0);

	std::map<int, std::string> mapAdapt;


	for(int i=0; i<fileAdaptivity.size(); i++)
	{
		std::string filename = fileAdaptivity[i];
		ifstream reading;
		std::string line, otype;

		reading.open(filename.c_str());
		if(reading.is_open())
		{
			do
			{
				std::getline(reading,line);
				std::stringstream ss;
				ss.str(trim(line));
				ss >> otype;
			} while(otype != "$ADAPTLEV");

			//READING NUMBER OF LATTICES IN THE SCENE
			std::stringstream s1;
			s1.str(trim(line));
			s1 >> otype >> remap[i];
		}
		else
		{
			std::cout<<"Failed to read file  "<<filename<<'\n';
			std::cout<<"Exiting....."<<'\n';
			exit(1);
		}
		reading.close();

		mapAdapt[remap[i]] = filename;
	}

	//check remap
	int mV;
	maxval(remap, mV);
	if((mapAdapt.size() == fileAdaptivity.size()) && (mV <= adaptivity_level))
	{
		check = true;
		int counter=0;
		for(std::map<int,std::string>::iterator itF = mapAdapt.begin(); itF!= mapAdapt.end(); itF++)
		{
			fileAdaptivity[counter] = (*itF).second;
			counter++;
		}//next iterator
	}

	return (check);
} //end f check ordering adaptivity file

void ControlDeformation::readAdaptivityFile(std::string & filename)
{
	ifstream reading;
	std::string line, otype;

	int actualLOA;
	int n_latt;
	reading.open(filename.c_str());
	if(reading.is_open())
	{
		do
		{
			std::getline(reading,line);
			std::stringstream ss;
			ss.str(trim(line));
			ss >> otype;
		} while(otype != "$ADAPTLEV");

		//READING level of adaptivity
		std::stringstream s1;
		s1.str(trim(line));
		s1 >> otype >> actualLOA;

		//check if all precedent level are defined
		int sizeLOAp =0;
		if((actualLOA-1) > 0)
		{
			sizeLOAp = adaptivityList[actualLOA-2].size();
		}
		else sizeLOAp = morphLattices.size();

		if (sizeLOAp == 0)
		{
			std::cout<<"wrong ordering of adaptivity lists! exiting...";
			exit(1);
		}

		do
		{
			std::getline(reading,line);
			std::stringstream ss;
			ss.str(trim(line));
			ss >> otype;
		} while(otype != "$NLATTICES");

		//READING NUMBER OF LATTICES to be adapted
		std::stringstream s2;
		s2.str(trim(line));
		s2 >> otype >> n_latt;

		//second check
		if(n_latt > sizeLOAp)
		{
			std::cout<<"Want to adapt more lattices than you have declared in the lower adaptivity level? How dare...Exiting!";
			exit(1);
		}

		//resize the actual level of adaptivity
		adaptivityList[actualLOA-1].resize(n_latt);

		//looping on declared lattices

		for(int j=0; j<n_latt; j++)
		{
			do
			{
				std::getline(reading,line);
				std::stringstream ss;
				ss.str(trim(line));
				ss >> otype;
			} while(otype != "$LATTICENAME");

			//READING NAME OF THE LATTICE
			std::stringstream s3;
			s3.str(trim(line));
			s3 >> otype >> adaptivityList[actualLOA-1][j].name;


			std::string fatherName;

			do
			{
				std::getline(reading,line);
				std::stringstream ss;
				ss.str(trim(line));
				ss >> otype;
			} while(otype != "$LATTICEFATHER");

			//READING NAME OF THE LATTICE FATHER
			std::stringstream s4;
			s4.str(trim(line));
			s4 >> otype >> fatherName;

			//search for the father in the precedent level of adaptivity
			LATTICE<3,4> * pointFather = findLattice(actualLOA-1, fatherName);


			ivector1D candidates;
			int value;
			do
			{
				std::getline(reading,line);
				std::stringstream ss;
				ss.str(trim(line));
				ss >> otype;

				if(otype == "$CANDIDATE")
				{
					ss >> value;
					candidates.push_back(value);
				}
			} while(otype != "$ENDCANDIDATES");

			do
			{
				std::getline(reading,line);
				std::stringstream ss;
				ss.str(trim(line));
				ss >> otype;
			} while(otype != "$LOADFILE");

			std::string dummy;
			//READING NAME OF THE LOAD FILE CONTROLLER
			std::stringstream s5;
			s5.str(trim(line));
			s5 >> otype >> dummy;
			adaptivityList[actualLOA-1][j].loadfile= input_folder+"/"+dummy;

			do
			{
				std::getline(reading,line);
				std::stringstream ss;
				ss.str(trim(line));
				ss >> otype;
			} while(otype != "$ENDLATTICE");


			std::cout<<"Performing refinement on lattice "<<adaptivityList[actualLOA-1][j].name<<'\n';
			//now set the lattice
			adaptivityList[actualLOA-1][j].compileAdaptive(candidates, pointFather);
		}//next j lattice

	}
	else
	{
		std::cout<<"Failed to read file  "<<filename<<'\n';
		std::cout<<"Exiting....."<<'\n';
		exit(1);
	}
	reading.close();

	//compute active nodes for the current level of adaptivity
	for(int i=0; i<n_latt; i++)
	{
		adaptivityList[actualLOA-1][i].computeActiveNodes();
	}
}// end of read adaptivity file

void ControlDeformation::readAdaptivityLoads()
{
	for(int i=0; i<adaptivity_level; i++)
	{
		for(int j=0; j<adaptivityList[i].size(); j++)
		{
			adaptivityList[i][j].readLoadFile();
		}//next j
	}//next i
}//end of readAdaptivityLoads

void ControlDeformation::writeAdaptivityLoads()
{
	for(int i=0; i<adaptivity_level; i++)
	{
		for(int j=0; j<adaptivityList[i].size(); j++)
		{
			adaptivityList[i][j].writeLoadTemplate();
		}//next j
	}//next i
}//end of writeAdaptivityLoads



LATTICE<3,4>* ControlDeformation::findLattice(int level, std::string & target)
{
	LATTICE<3,4> * result = NULL;
	int itype, counter;
	bool check;

	if (level==0) itype = 0;
	else  		  itype = 1;


	counter = 0;
	check = false;


	switch(itype)
	{
	case 0:
		while(counter<nLattices && !check)
		{
			if(morphLattices[counter].name == target) check =true;
			counter++;
		}

		if(check) result = &morphLattices[counter-1];
		break;
	case 1:
		while(counter<adaptivityList[level-1].size() && !check)
		{
			if(adaptivityList[level-1][counter].name == target) check =true;
			counter++;
		}

		if(check) result = &adaptivityList[level-1][counter-1];
		break;

	default:
		//never reached
		break;
	}

	if(!check)
	{
		std::cout<<"Not found in the row "<< (level-1)<<  "of adaptivityList/morphLattices, the lattice named: "<<target<<'\n';
		std::cout<<"Recheck your control files,  meanwhile I'm exiting..."<<'\n';
		exit(1);
	}

	return (result);
}//end of find Lattice

ControlSurfaceDeformation::ControlSurfaceDeformation (std::string input_lattice, std::string inputFolder)
{ // read the input of lattices from file and set the vector of lattices.

	nLattices = 0;
	input_folder = inputFolder;
	// workspace
	ifstream reading;
	int  jdir, kcount;
	std::string line, direction, otype;
	std::vector<int> ii(3,0), nn(3,0);
	double value;


	// open file input_lattice and check the result
	reading.open(input_lattice.c_str());

	if (reading.is_open())   // check: successfully opened, proceed
	{
		readNumberLattices(reading);

		for(int kLat = 0; kLat<nLattices; kLat++)
		{
			morphLattices[kLat].name = readLatticeName(reading);
			morphLattices[kLat].RefineSupport=readRefineFlag(reading);

			std::string fileMode;
			readSelectionMode(reading, inputFolder, morphLattices[kLat].mode, fileMode);

			if(morphLattices[kLat].mode == "BYPATCHES") {morphLattices[kLat].file_patch=fileMode;}
			else										{morphLattices[kLat].file_external=fileMode;}


			ivector1D ndim = readLatticeDim(reading);
			int size_lattice =1;
			for(int i=0; i<3; ++i){
				morphLattices[kLat].n[i] = ndim[i];
				size_lattice = size_lattice * (ndim[i]+1);
			}
			//define the total number of DOF in the kLat lattice
			morphLattices[kLat].n_points = size_lattice ;
			// allocate the structure of coordinates point of lattice
			morphLattices[kLat].points = new lattice_pt<3> [size_lattice];


			dvector1D seed;
			svector1D ngeos;
			bvector1D checkBC=readBoundaryConditions(reading,inputFolder,morphLattices[kLat].boundary ,seed, ngeos);

			//check immediately
			if(checkBC[0]){
				std::cout<<"WARNING! Some mispelled BC strings found. CAMILO reset them to default values C2."<<endl;
			}

			if(checkBC[1]){
				std::cout<<"ERROR! defining Seed point or Neighbors geometries for multi BC definition. Some files does not exists or are corrupted Or not admissible values declared."<<endl;
				std::cout<<"Check them in the designed Input folder. For now exit CAMILO!"<<endl;
				exit(1);
			}

				morphLattices[kLat].seedPointBoundary.resize(seed.size(),0);
				morphLattices[kLat].seedPointBoundary=seed;

				morphLattices[kLat].geo_segmented.resize(ngeos.size(),"");
				morphLattices[kLat].geo_segmented = ngeos;

			morphLattices[kLat].transition = 1.0;
			morphLattices[kLat].loadfile = readLoadFileInfo(reading, inputFolder);

			readEndLattice(reading);
		}// end of loop on lattices

	} // end of if reading

	else{std::cout<<"WARNING! cannot find the file for Reading the Lattice config "<<input_lattice << " in folder Input.Please check"<<endl;exit(1);}
	reading.close();
} // end of CONSTRUCTOR
ControlSurfaceDeformation::~ControlSurfaceDeformation()
{

}

void ControlSurfaceDeformation::readNumberLattices(ifstream & input)
{
	std::string line, otype;
	int countRead = 0;

	do{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$NLATTICES" );

	//READING NUMBER OF LATTICES IN THE SCENE
	std::stringstream s1;
	s1.str(trim(line));
	s1 >> otype >> nLattices;
	morphLattices.resize(nLattices);

};

std::string ControlSurfaceDeformation::readLatticeName(ifstream & input)
{
	std::string result, line,otype;
	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$SURFLATTICE");

	std::stringstream s0;
	s0.str(trim(line));
	s0>>otype>>result;
	return(result);
};

bool ControlSurfaceDeformation::readRefineFlag(ifstream & input)
{
	bool result=false;
	std::string line, otype;
	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$REFINE");

	//READING if MUST be REFINE SUPPORT IN THE SCENE

	std::stringstream s1;
	s1.str(trim(line));
	int checkRefine;
	s1>>otype>>checkRefine;
	if(checkRefine > 0) {result=true;}
	return(result);
};

void ControlSurfaceDeformation::readSelectionMode(ifstream & input, std::string & folder, std::string &method, std::string &file)
	{
		std::string line, otype, append;

		do
		{
			std::getline(input, line);
			std::stringstream ss;
			ss.str(trim(line));
			ss>>otype;
		} while(otype !="$MODE");


		//READING THE MODE FOR TASSELATION SELECTION
		std::stringstream s0;
		s0.str(trim(line));
		s0 >> otype >> method ;

		//check for mispelling in mode keyword

		if((method != "BYPATCHES") && (method != "BYFILE")) {method="BYFILE";}

		do
		{
			std::getline(input, line);
			std::stringstream ss;
			ss.str(trim(line));
			ss>>otype;
		} while(otype !="$FILENAME");


		//READING THE RIGHT FILENAME FOR TASSELATION SELECTION
		std::stringstream s1;
		s1.str(trim(line));

			s1 >> otype >> append;
			file =folder+"/"+append;

	};
/*! get lattice characteristics such as origin, span and dimension in lattice dictionaries */
ivector1D ControlSurfaceDeformation::readLatticeDim(ifstream & input)
{


	ivector1D ndim(3,0);
	std::string line,otype;

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$DIMENSION");

	//READING THE DOF NUMBERS OF LATTICE, IN EACH DIRECTION
	std::stringstream s2;
	s2.str(trim(line));
	s2 >> otype;
	s2 >> ndim[0]>>ndim[1]>>ndim[2];

	return(ndim);

};
bvector1D ControlSurfaceDeformation::readBoundaryConditions(ifstream & input, std::string & folder, ivector1D & bcs, dvector1D &seed, svector1D & neigh_geos)
{
	bvector1D check(2, false);
	bool flagtype;
	std::string line, otype, bctype;
	svector1D bcstr;
	neigh_geos.resize(4,"");

	bcs.resize(4,0); bcstr.resize(4,"");

	do{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
		} while(otype != "$BCS");


		std::stringstream s1;
		s1.str(trim(line));
		s1 >> otype >> bcstr[0] >>bcstr[1]>>bcstr[2]>>bcstr[3];

		for(int i=0; i<4; ++i){
			bcs[i]=(bcstr[i]=="F") + (bcstr[i]=="C0")*2 + (bcstr[i]=="C1")*3 + (bcstr[i]=="C2")*4 -1;
			if (bcs[i] == -1)
			{
				check[0]=true;
				//snooze to default -->
				bcs[i]=3;
			}
		}

		//find first of BYNEIGHS and SEED methods
		do
		{
			std::getline(input,line);
			std::stringstream ss;
			ss.str(trim(line));
			ss >> otype;
		} while(otype != "$BYNEIGHS" && otype != "$SEED" && otype != "$ENDSURFLATTICE");

		if(otype == "$ENDSURFLATTICE")
		  {
			std::cout<<"Error reading Lattice input. Missing $BYNEIGHS or $SEED value. Exiting"<<endl;
			exit(1);
			}


		if(otype == "$BYNEIGHS"){
			//READING THE transition of geodesic filter
			std::stringstream s2;
			s2.str(trim(line));
			s2 >> otype >> neigh_geos[0]>> neigh_geos[1]>> neigh_geos[2]>> neigh_geos[3];

			//check immediatly
			for(int k=0; k<4; ++k){

				check[1]= check[1] || (neigh_geos[k].empty());
				std::stringstream ss;
				ss<<folder<<"/"<<neigh_geos[k];
				neigh_geos[k]=ss.str();

				ifstream checkRead;
				checkRead.open(neigh_geos[k].c_str());
				check[1]= check[1] || (!checkRead.is_open());

				if(checkRead.is_open()){checkRead.close();}
			}
		}

		if(otype == "$SEED"){
			//READING THE transition of geodesic filter
			std::stringstream s2;
			s2.str(trim(line));
			s2 >> otype >> seed[0]>> seed[1]>> seed[2];

			double norm = norm_2(seed);
			if(std::isnan(norm)){check[1]=true;}

		}


return(check);

};
std::string ControlSurfaceDeformation::readLoadFileInfo(ifstream & input, std::string & folder)
{
	std::string loadfile, line, otype;

	do
	{
		std::getline(input,line);
		std::stringstream ss;
		ss.str(trim(line));
		ss >> otype;
	} while(otype != "$FILELOAD");

	//READING THE file name of lattice loads
	std::stringstream s0,s1;
	std::string loaddummy;
	s0.str(trim(line));
	s0 >> otype >> loaddummy;

	s1<<folder<<"/"<<loaddummy;

	loadfile= s1.str();
	return (loadfile);
};
/*! read end lattice */
void ControlSurfaceDeformation::readEndLattice(ifstream & input)
{
	std::string line, otype;
	do{
		std::stringstream ss;

		std::getline(input,line);
		ss.str(trim(line));
		ss >> otype;
	} while(otype !="$ENDSURFLATTICE");


};


#include "libRA_DefSelection.hpp"

void FFDSEL_EXT::selectingTriangulation(ControlDeformation & Up, SHAPE & sh)
    {	
// SELECTION PHASE ---> how to select your support?
// 4 choices :
//		- Default  : DO NOTHING. Support will be defined by all Simplex included in the local Lattice.	
//		- selectIN : restrict the Default selection to those simplexes included in a patch, marked as patchINCLUDE
//		- selectOUT: cut off simplexes included in a patch, marked as patchEXCLUDE, from a given selected tasselation (both Default or selectIN)
//		- fromFILE: read a list of simplex from file 

// All operations are performed on the megaUltravector markInclusion for each single lattice. 
		

     	for(int jLatt=0; jLatt<Up.morphLattices.size(); jLatt++)
		{
     	 selectTriangles(Up.morphLattices[jLatt], sh, jLatt);
		}//next jLatt

	};//end selectingTriangulation


void FFDSEL_EXT::selectingTriangulation(ControlSurfaceDeformation & Up, SHAPE & sh)
    {
// SELECTION PHASE ---> how to select your support?
// 4 choices :
//		- selectIN : restrict the Default selection to those simplexes included in a patch, marked as patchINCLUDE
//		- selectOUT: cut off simplexes included in a patch, marked as patchEXCLUDE, from a given selected tasselation (both Default or selectIN)
//		- fromFILE: read a list of simplex from file

// All operations are performed on the megaUltravector markInclusion for each single lattice.

	  	for(int jLatt=0; jLatt<Up.morphLattices.size(); jLatt++)
		{
		 selectTriangles(Up.morphLattices[jLatt], sh, jLatt);
         	}//next jLatt

	};//end selectingTriangulation

void FFDSEL_EXT::selectTriangles(LATTICE<3,4> & latt, SHAPE & sh, int counter)
    {
// SELECTION PHASE ---> how to select your support?
// 4 choices :
//		- Default  : DO NOTHING. Support will be defined by all Simplex included in the local Lattice.
//		- selectIN : restrict the Default selection to those simplexes included in a patch, marked as patchINCLUDE
//		- selectOUT: cut off simplexes included in a patch, marked as patchEXCLUDE, from a given selected tasselation (both Default or selectIN)
//		- fromFILE: read a list of simplex from file

// All operations are performed on the megaUltravector markInclusion for each single lattice.

		 std::string modeSelection;
		 modeSelection = latt.mode;

		 std::vector<double> origin(3,0.0), span(3,1.0);

		 origin = latt.origin;
		 span   = latt.span_lattice;


		 if (modeSelection == "BYPATCHES")
		    {
		     Selection triMorph(latt.file_patch, latt.origin, latt.span_lattice);
		     triMorph.readUserGraphSelections();
		     //start working with inclusive Patches/PID ==========================>

		     if((triMorph.numberInclusivePatch !=0) ||(triMorph.numberInclusivePID !=0))
			{ //reset the markInclusion  of current jLatt to -1

			    for(int k=0; k<sh.markInclusion.size(); k++)
				{
				if(sh.markInclusion[k] == counter) sh.markInclusion[k] = -1;
				}
			}

		     for(int jP=0; jP<triMorph.numberInclusivePatch; jP++)
			{
			 triMorph.inclusivePatch[jP].set_planes();
			 triMorph.inclusivePatch[jP].include_triangulation(sh, counter,origin, span);

			}

		     // ok check for oversized patches, including simplicies out of lattice volume
		     latt.Hull.checkInclusion(sh,counter, origin, span);

			 //start working with inclusive PID ==========================>

		     for(int jP=0; jP<triMorph.numberInclusivePID; jP++)
			{
			latt.Hull.include_PID(sh, counter,origin, span, triMorph.inclusivePID[jP]);
			}

		     //start working with exclusive Patches ============================>

		     for(int jP=0; jP<triMorph.numberExclusivePatch; jP++)
			{

			 triMorph.exclusivePatch[jP].set_planes();
			 triMorph.exclusivePatch[jP].exclude_triangulation(sh, counter,origin,span);
			}

			 //start working with exclusive PID ==========================>

		     for(int jP=0; jP<triMorph.numberExclusivePID; jP++)
			{
			latt.Hull.exclude_PID(sh,counter,origin, span, triMorph.exclusivePID[jP]);
			}

		    }// endif BYPATCH



		  if(modeSelection =="BYFILE")
		    {

			 //reset the markInclusion  of current jLatt to -1

			  int sizeMK = sh.markInclusion.size();
			  for(int k=0; k<sizeMK; ++k)
			  {
				  if(sh.markInclusion[k] == counter) {sh.markInclusion[k] = -1;}
			  }

			  Class_SurfTri append;

      		SELECTION_EXT::readSelection(latt.file_external, append);
			ivector1D listSimplicies = SELECTION_EXT::mapBinSort(*(static_cast<Class_SurfTri * > (&sh)), append);


			int ls_size = listSimplicies.size();
			for(int ik=0; ik<ls_size; ik++)
			  {
				int check = listSimplicies[ik];
				sh.markInclusion[check] = counter;
			  }

			// ok check for oversized selections, including simplicies out of lattice volume
				latt.Hull.checkInclusion(sh,counter, origin, span);

		    }//endif BYFILE


	};//end selectingTriangulation


void FFDSEL_EXT::selectTriangles(SURFLATTICE & latt, SHAPE & sh, int counter)
    {
// SELECTION PHASE ---> how to select your support?
// 4 choices :
//		- selectIN : restrict the Default selection to those simplexes included in a patch, marked as patchINCLUDE
//		- selectOUT: cut off simplexes included in a patch, marked as patchEXCLUDE, from a given selected tasselation (both Default or selectIN)
//		- fromFILE: read a list of simplex from file

// All operations are performed on the megaUltravector markInclusion for each single lattice.

	 dvector1D origin(3,0.0), span(3,1.0);
	 dvector1D xlim(2,0), ylim(2,0), zlim(2,0);

	 sh.BoundingBox(xlim,ylim,zlim);

	 origin[0] = xlim[0];
	 span[0]   = xlim[1]-xlim[0];

	 origin[1] = ylim[0];
	 span[1]   = ylim[1]-ylim[0];

	 origin[2] = zlim[0];
	 span[2]   = zlim[1]-zlim[0];

	 //define a default Hull;
	 PATCH<3> Hull;
    Hull.vertices[0][0] = 0.0; Hull.vertices[0][1] = 0.0; Hull.vertices[0][2] =0.0;
    Hull.vertices[1][0] = 1.0; Hull.vertices[1][1] = 0.0; Hull.vertices[1][2] =0.0;
    Hull.vertices[2][0] = 1.0; Hull.vertices[2][1] = 1.0; Hull.vertices[2][2] =0.0;
    Hull.vertices[3][0] = 0.0; Hull.vertices[3][1] = 1.0; Hull.vertices[3][2] =0.0;
    Hull.vertices[4][0] = 0.0; Hull.vertices[4][1] = 0.0; Hull.vertices[4][2] =1.0;
    Hull.vertices[5][0] = 1.0; Hull.vertices[5][1] = 0.0; Hull.vertices[5][2] =1.0;
    Hull.vertices[6][0] = 1.0; Hull.vertices[6][1] = 1.0; Hull.vertices[6][2] =1.0;
    Hull.vertices[7][0] = 0.0; Hull.vertices[7][1] = 1.0; Hull.vertices[7][2] =1.0;

    Hull.set_planes();

		 std::string modeSelection;
		 modeSelection = latt.mode;

		 if (modeSelection == "BYPATCHES")
		    {
		     Selection triMorph(latt.file_patch, origin, span);
		     triMorph.readUserGraphSelections();
		     //start working with inclusive Patches/PID ==========================>

		     if((triMorph.numberInclusivePatch !=0) ||(triMorph.numberInclusivePID !=0))
			{ //reset the markInclusion  of current jLatt to -1

			    for(int k=0; k<sh.markInclusion.size(); k++)
				{
				if(sh.markInclusion[k] == counter) sh.markInclusion[k] = -1;
				}
			}

		     for(int jP=0; jP<triMorph.numberInclusivePatch; jP++)
			{
			 triMorph.inclusivePatch[jP].set_planes();
			 triMorph.inclusivePatch[jP].include_triangulation(sh,counter,origin, span);

			}

			 //start working with inclusive PID ==========================>

		     for(int jP=0; jP<triMorph.numberInclusivePID; jP++)
			{
		    	 Hull.include_PID(sh,counter,origin, span, triMorph.inclusivePID[jP]);
			}

		     //start working with exclusive Patches ============================>

		     for(int jP=0; jP<triMorph.numberExclusivePatch; jP++)
			{

			 triMorph.exclusivePatch[jP].set_planes();
			 triMorph.exclusivePatch[jP].exclude_triangulation(sh, counter,origin,span);
			}

			 //start working with exclusive PID ==========================>

		     for(int jP=0; jP<triMorph.numberExclusivePID; jP++)
			{
		    	 Hull.exclude_PID(sh, counter,origin, span, triMorph.exclusivePID[jP]);
			}

		    }// endif BYPATCH



		  if(modeSelection =="BYFILE" || modeSelection =="DEFAULT")
		    {

			 //reset the markInclusion  of current jLatt to -1
      		    for(int k=0; k<sh.markInclusion.size(); k++)
			{
			if(sh.markInclusion[k] == counter) sh.markInclusion[k] = -1;
			}


			Class_SurfTri append;
			SELECTION_EXT::readSelection(latt.file_external, append);
			ivector1D listSimplicies = SELECTION_EXT::mapBinSort(*(static_cast<Class_SurfTri *> (&sh)), append);


			for(int ik=0; ik<listSimplicies.size(); ik++)
			  {
			   sh.markInclusion[listSimplicies[ik]] = counter;
               }

		    }//endif BYFILE

	};//end selectTriangles


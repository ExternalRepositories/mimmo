#include "libRA_FFD.hpp"

//libRA_FFD.hpp coding


double FFD_Ext::constraint(int & iVert, LATTICE<3,4> & pG)
{
	/* function define value of planck taper window functions to vinculate deformation in prescribed zones of the lattice*/

	//i/o declarations

	double  vinculate = 1.0e0;
	if(pG.bc_segmented.size() != 4){
		vinculate = filterWindow(pG.puntSelection->SDFTri[iVert],
								 pG.transition,
								 pG.boundary,
								 pG.boundary_int,
								 true);
	}

	else{
		 vinculate = vinculate * filterWindow(pG.puntSelection->xyMap[iVert][0],
				 	 	 	 	 	 	 	  pG.transition,
											  pG.bc_segmented[0],
											  pG.bc_segmented[2],
											  false);

		vinculate = vinculate * filterWindow(pG.puntSelection->xyMap[iVert][1],
											 pG.transition,
											 pG.bc_segmented[1],
											 pG.bc_segmented[3],
											 false);
	}

	return(vinculate);

} //end of function constraint

double FFD_Ext::constraint(int & iVert, SURFLATTICE & pG)
{
	/* function define value of planck taper window functions to vinculate deformation in prescribed zones of the lattice*/

	//i/o declarations

	double  vinculate = 1.0e0;

	vinculate = vinculate*filterWindow(pG.puntSelection->xyMap[iVert][0], pG.transition, pG.boundary[0], pG.boundary[2], false);
	vinculate = vinculate*filterWindow(pG.puntSelection->xyMap[iVert][1], pG.transition, pG.boundary[1], pG.boundary[3], false);

	return(vinculate);

} //end of function constraint


double  FFD_Ext::filterWindow (double xval,double sum, int  b0, int b1, bool internal )
{// evaluate value of the window function once the coordinate xval defined in [xmin,xmax] is given  //
	// the filter is defined on the whole domain with a unique polynomial function. The degree of the polynomial
	// and the shape of the function are determined by imposing the boundary condition cont1 e cont2 (free bc's,
	// c0 ,c1 constraint). If a antideformative patch is included, shape filter is consequently rearranged.

	// I/O stats
	double value_f=0.0e0;
	// workspace
	int label,itype, boundary, boundary2;

	if(sum > 1){ std::cout<<"WARNING:filter window is out of maximum value of 1"<<endl;
	}

	if(sum < 0.0){sum = 1.0;}

	if (xval >= 0.0){
		//resolving first dependancy. If sum, interval span is ==1, boundary2 == C0, else boundary2 ==C2
		// condition of continuity are marked as Free = 0; C0 = 1; C1 = 2; C2 = 3;

		boundary = b0;
		boundary2 = b1;
		double check = 1.0*((int) internal);

		label = 4*boundary + boundary2 ;
		value_f = 0.0;


		double target = xval/sum;
		if(target > 1.0){label=16;}

		switch(label)
		{
		case 0 : value_f = 1.0; 							  		 			 				break;
		case 1 : value_f = (check) * 1.0 + (1.0-check)*(1.0-target);			 				break;
		case 2 : value_f = (check) * 1.0 + (1.0-check)*(1.0- 2.0*target + pow(target,2));		break;
		case 3 : value_f = (check) * 1.0 +
				(1.0-check)*(1.0- 3.0*target + 3.0*pow(target,2) - pow(target,3));	break;

		case 4 : value_f = target;					  			 							break;
		case 5 : value_f = check 			* target +
				(1.0 - check)  * (4.0*target - 4.0*pow(target,2));					break;

		case 6 : value_f = check 			* (2.0*target - 1.0*pow(target,2)) +
				(1.0 - check)  * (27.0/4.0)*(target - 2.0*pow(target,2) + pow(target,3)); break;

		case 7 : value_f = check 			* (3.0*target - 3.0*pow(target,2) + pow(target,3)) +
				(1.0 - check)  * (-256.0/27.0)*(-1.0*target + 3.0*pow(target,2) -3.0* pow(target,3) +
						pow(target,4)); 						   break;


		case 8 : value_f = pow(target,2); 									   			 		   break;
		case 9 : value_f = check 			* pow(target,2) +
				(1.0 - check)  * (-27.0/4.0)*(-1.0*pow(target,2) + pow(target,3));        break;
		case 10: value_f = check 			* (3.0*pow(target,2) - 2.0*pow(target,3)) +
				(1.0 - check)  * (16.0)*(pow(target,2) -2.0*pow(target,3) +pow(target,4)); break;

		case 11: value_f = check 			* (6.0*pow(target,2) -8.0*pow(target,3) +3.0*pow(target,4)) +
				(1.0 - check)  * (3125.0/108)*(pow(target,2) - 3.0*pow(target,3) +3.0*pow(target,4) - pow(target,5)); break;

		case 12: value_f = (pow(target,3));															break;

		case 13: value_f = check 			* (pow(target,3)) +
				(1.0 - check)  * (-256.0/27.0)*(-1.0*pow(target,3) +1.0*pow(target,4));     break;

		case 14: value_f = check 			* (4.0*pow(target,3) - 3.0*pow(target,4)) +
				(1.0 - check)  * (3125.0/108)*(1.0*pow(target,3) -2.0*pow(target,4) + pow(target,5));     break;


		case 15: value_f = check 			* (10.0*pow(target,3) - 15.0*pow(target,4) + 6.0*pow(target,5)) +
				(1.0 - check)  * (-64.0)*(-1.0*pow(target,3) +3.0*pow(target,4) -3.0*pow(target,5) + pow(target,6.0));     break;

		case 16: value_f = 1.0;						break;
		default: //never been reached;
		break;
		}//end switch
	}


	return(value_f);

};//end of twindow

//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

bool FFD_Ext::collision_WConstr(TRIANGLE_INTERSECTIONS * insectK,
		int & iV,
		int & iT,
		dvector1D & direction,
		double & result,
		int & resultTriSupport	)
{

	result = 0.0;
	resultTriSupport=-1;
	bool checkout = false;

	dvector1D res = conVect(insectK->puntOriginal->Vertex[iV]);
	RayIntersectOutput out = insectK->intersect_RayTri(res, direction);

	if(out.raytr_delta.size()!=0)
	{
		minval(out.raytr_delta, result);
		int pos = posVectorFind(out.raytr_delta, result);
		resultTriSupport = out.raytr_map[pos];
		checkout=true;
	}

	return (checkout);
}

void FFD_Ext::wConstr0_WholeBody(dvector1D & allow_disp,
		ivector1D & triSupport,
		ivector1D & map,
		Class_SurfTri * constraint,
		dvector2D & displacements,
		int & pos)
{

	if(map.size() == 0) {return;}

	dvector1D comp(allow_disp.size(),0.0);
	for(int i = 0; i< map.size(); i++)       // counting on shape points selected
	{
		int i_p = map[i];
		comp[i] = norm_2(displacements[i_p]) - allow_disp[i];
	}//next i_p

	double max_distance;
	maxval(comp, max_distance);

	pos = posVectorFind(comp, max_distance);
	int targetTri=triSupport[pos];

	double scale = 1.0 - max_distance/norm_2(displacements[map[pos]]);

	for(int i = 0; i< displacements.size(); i++) {      // counting on shape points selected

		displacements[i]= scale*displacements[i];
	}//next i

}//end of wConstr0_WholeBody

void FFD_Ext::wConstr1_FitBody(dvector1D & allow_disp,
		ivector1D & map,
		dvector2D & displacements)
{

	if(map.size() == 0) {return;}
	for(int i = 0; i< map.size(); i++)       // counting on shape points selected
	{
		int i_p = map[i];

		if(norm_2(displacements[i_p]) - allow_disp[i] >= 0 ){
			double allowTol= allow_disp[i];
			displacements[i_p]= displacements[i_p]/norm_2(displacements[i_p]);
			displacements[i_p] = allowTol * displacements[i_p];
		}
	}//next i_p

}//end of wConstr1_FitBody

dvector1D FFD_Ext::deCasteljauEvaluator(SURFLATTICE & lattice, dvector1D & coord)
{
	dvector1D val(3,0.0);
	dvector2D temp2, work;

	// surflattice map is bidimensional. Info are contained in n[0]-n[1] nodes
	// start of De Casteljau algorithm........................................................
	work.resize(lattice.n[0]+1, dvector1D(3, 0.0e0));
	temp2.resize(lattice.n_points, dvector1D(3,0.e0));


	for  (int j2=0; j2<=lattice.n[1]; j2++)
	{
		for(int j1=0; j1<= lattice.n[0]; j1++)
		{

			int i_l = j2*(lattice.n[0]+1) + j1;
			// store loads on x points in temporary matrix work
			for(int intv=0; intv<3; intv++) work[j1][intv] = lattice.points[i_l].load[intv];
		}// next j1

		// call to function BernCast -> obtain partial local deformations
		//on grid nz_lattice*nylattice, with fixed quote x=coord[0]
		BernCast<3>(lattice.n[0], work, coord[0],val);
		temp2[j2] = val;

	}// next j2


	// reducing the 2D lattice grid in 1D grid, with constant y=coord[1] and,
	// whenever defined by Dim, z = coord[2]..................
	freeContainer(work);
	work.resize(lattice.n[1]+1,dvector1D(3, 0.0e0));

	for  (int j1 = 0; j1<=lattice.n[1]; j1++)
	{
		int i_l = j1;
		// store loads on y points in temporary matrix work
		work[j1] = temp2[i_l];
	}// next j1

	// call to function BernCast -> obtain partial local deformations on grid nx_lattice,
	//with fixed widht y=coord[1] and, whenever defined by Dim,  with fixed quote z=coord[2]
	BernCast< 3 > (lattice.n[1], work, coord[1],val);

	return (val);
}

void FFD_Ext::deformation( dvector2D & vertex,
		dvector2D & result,
		SURFLATTICE & lattice,
		dvector1D * deformability
)
{


	// Workspace..................................
	int     n_lattice[3]; // dimension, in each direction x,y,z of lattice mesh
	int     n_points, n_lattice_tot; // total dimension of struct SHAPE and LATTICE, respectively
	double  vinculate, check_pid;

	dvector1D val(3,0.0);

	// write the original cloud points in lattice local sdr
	dvector2D deform(vertex.size(), dvector1D(3,0.0));
	// setting dimensions of lattice for internal use of the function
	for(int intv=0; intv<3; intv++) n_lattice[intv] =  lattice.n[intv];

	// setting dimensions of structures
	n_lattice_tot =  lattice.n_points;
	n_points= lattice.puntSelection->mapMotherV.size() ;

	for(int i_px = 0; i_px < n_points; i_px++)       // counting on shape points selected
	{
		int i_p = lattice.puntSelection->mapMotherV[i_px];

		for(int intv=0;intv<3;intv++) deform[i_p][intv] = 0.0e0; //initialization

		val = deCasteljauEvaluator(lattice, lattice.puntSelection->xyMap[i_px]);
		vinculate = FFD_Ext::constraint(i_px, lattice);

		if(deformability != NULL) (*deformability)[i_p] = vinculate;
		deform[i_p] = vinculate*val;
	} // next i_p - cycling on the point of SupportMesh triangulation


	//terminate your stuff
	int sizeV = vertex.size();
	for(int i=0; i<sizeV; ++i)
	{// updating the value in *.deform with the effective position of deformed shape points, not only their displacement
		result[i] = deform[i] + vertex[i];
	} //next i vertex

} //................ end of function deformation


void FFD_Ext::deformation( dvector2D & vertex,
						   dvector2D & result,
						   SURFLATTICE & lattice,
						   SHAPE * Oshape,
						   Class_SurfTri * Cshape,
						   int * controlType,
						   double * controlTol,
						   bool * coplanCheck,
						   Class_UCartMesh3D * Bmesh,
						   dvector1D & Cdistance,
						   dvector1D * deformability)
{

	//HEADCHECK - check coherence on the optional inputs
	bool check1= (controlType!=NULL) && (Cshape ==NULL);
	bool check2= (controlType!=NULL) && (Oshape ==NULL);
	bool check4= (controlType==NULL) && (Cshape !=NULL);

	if(check1 || check2 || check4)
	{
		std::cout<<"Incoherent calling of optional inputs for collision checking."  << '\n' ;
		std::cout<<"Please recheck your call to deformation function in the code" <<'\n' ;
		std::cout<<"Exiting now..."<<'\n';
		exit(1);
	}

	// Workspace..................................
	int     n_lattice[3]; // dimension, in each direction x,y,z of lattice mesh
	int     n_points, n_lattice_tot; // total dimension of struct SHAPE and LATTICE, respectively
	double  vinculate, check_pid;

	int globCounterCollision=0;
	int failCollision=0;
	TRIANGLE_INTERSECTIONS insectK;
	dvector1D allowDisp;
	ivector1D allowSupp;
	ivector1D mapCollision;
	double tolerance = 0.0;
	dvector1D val(3,0.0);

	// write the original cloud points in lattice local sdr
	dvector2D deform(vertex.size(), dvector1D(3,0.0));

	// setting dimensions of lattice for internal use of the function
	for(int intv=0; intv<3; intv++) n_lattice[intv] =  lattice.n[intv];

	// setting dimensions of structures
	n_lattice_tot =  lattice.n_points;
	n_points= lattice.puntSelection->mapMotherV.size() ;

	allowDisp.resize(n_points,0.0);
	allowSupp.resize(n_points,0);
	mapCollision.resize(n_points,-1);

	for(int i_px = 0; i_px < n_points; i_px++)       // counting on shape points selected
	{
		int i_p = lattice.puntSelection->mapMotherV[i_px];

		for(int intv=0;intv<3;intv++) deform[i_p][intv] = 0.0e0; //initialization

		val = deCasteljauEvaluator(lattice, lattice.puntSelection->xyMap[i_px]);
		vinculate = FFD_Ext::constraint(i_px, lattice);

		if(deformability != NULL) (*deformability)[i_p] = vinculate;
		deform[i_p] = vinculate*val;

		//now check collisions if available
		if(controlType != NULL)
		{
			//check tolerance

			if(controlTol!=NULL) {tolerance = *controlTol;}

			//allocate back-support structure
			double disp;
			int tri;

			// prepare TRIANGLE_INTERSECTIONS
			insectK.puntOriginal = Oshape;
			insectK.puntConstraint= Cshape;


			// convert your fresh deformation in the original s.d.r
			dvector1D direction(3,0.0); direction = deform[i_p];

			bool checkColl = collision_WConstr(&insectK, i_p, Oshape->InverseSimplexMap[i_p][0],
					direction,disp, tri);

			if(checkColl)
			{
				allowDisp[globCounterCollision]=disp;
				allowSupp[globCounterCollision]=tri;
				mapCollision[globCounterCollision]=i_p;
				globCounterCollision++;
			}

		}//end if check on collision
	} // next i_p - cycling on the point of SupportMesh triangulation

	//specialize your control tecnique, according to the collision control type you selected

	allowDisp.resize(globCounterCollision);
	allowSupp.resize(globCounterCollision);
	mapCollision.resize(globCounterCollision);

	dvector1D xOR, updDef, interval;
	//now check if whole field control is active
	if(controlType != NULL && *controlType==0)
	{
		std::cout<<"Found  "<<globCounterCollision<<" possible collision in your scene. Going to cure it w/ a whole field control tech."<<'\n';

		int posix;

		int size_deform=deform.size();
		dvector2D deform_temp(size_deform,dvector1D(3,0));
		for(int kk=0; kk<size_deform; ++kk){deform_temp = deform;}

		wConstr0_WholeBody(allowDisp,allowSupp,mapCollision,Cshape, deform_temp, posix);

		double vInterp, sign,diff,rescale;
		updDef = deform_temp[mapCollision[posix]];
		interval = updDef;
		bool checkLS = true;

		int esc=0;
		while (checkLS){ //iteratively check max displacement with respect to constraint levelset
			xOR = vertex[mapCollision[posix]]+updDef;
			Bmesh->interpolatePointData(xOR,Cdistance,vInterp);
			diff=tolerance-vInterp;

			if( abs(diff)/tolerance < 10e-6 || esc>1000) checkLS = false;
			else {
				sign=getSign(diff);
				interval=interval/2.0;
				updDef=updDef-sign*interval;
				++esc;
			}
		}
		rescale=norm_2(updDef)/norm_2(deform_temp[mapCollision[posix]]);
		std::cout<<"Rescaling factor for whole_constr method :  "<< rescale << endl;
		result=deform_temp*rescale+vertex;

		std::cout<<"Reducing displacements done"<<'\n';
	}

	//now check if fit constraint body control is active
	if(controlType != NULL && *controlType==1)
	{
		std::cout<<"Found  "<<globCounterCollision<<" possible collision in your scene. Going to cure it w/ a fit constraint body control tech."<<'\n';

		ivector1D posix;

		int size_deform=deform.size();
		dvector2D deform_temp(size_deform,dvector1D(3,0));
		for(int kk=0; kk<size_deform; ++kk){deform_temp = deform;}

		wConstr1_FitBody(allowDisp,mapCollision,deform_temp);

		double vInterp, sign, diff;
		for(int i=0; i<globCounterCollision; ++i){
			xOR = vertex[mapCollision[i]]+deform_temp[mapCollision[i]];
			Bmesh->interpolatePointData(xOR,Cdistance,vInterp);

			if(tolerance>=vInterp) posix.push_back(i);

		}

		int nposix=posix.size();
		for(int i=0; i<nposix; ++i){

			updDef = deform_temp[mapCollision[posix[i]]];
			interval = updDef;
			bool checkLS = true;
			int esc=0;

			while (checkLS){ //iteratively check each displacement with respect to constraint levelset
				xOR = vertex[mapCollision[posix[i]]]+updDef;
				Bmesh->interpolatePointData(xOR,Cdistance,vInterp);
				diff=tolerance-vInterp;

				if( abs(diff)/tolerance < 10e-6 || esc>1000) checkLS = false;
				else {
					sign=getSign(diff);
					interval=interval/2.0;
					updDef=updDef-sign*interval;
					++esc;
				}
			}
			deform_temp[mapCollision[posix[i]]]=updDef;

		}

		result=deform_temp+vertex;
		//deform = lattice.remapORToLattice(deform_temp);

		std::cout<<"Reducing displacements done"<<'\n';

	}//endif *controlType=1

} //................ end of function deformation


// void FFD_Ext::BernVS(int n, dvector2D & ld, double coord , dvector1D & val )
// {
//   //implementing VS method by Schumacker&Volk for Bezier curve evaluation.
//   //Requires load pre-multiplied by its relative binomiala coefficients.
//   int    iflag = (coord >=0.5);
//   double fflag = iflag;
//   
//   double cc = fflag*(coord/(1.0 - coord)) + (1 - fflag)*((1.0 - coord)/coord);
//   val = fflag*(ld[0]) + (1 - fflag)*ld[n];
//   double exp = fflag*coord + (1 - fflag)*(1.0-coord);
//   double count = exp;
//   int end = iflag*n;
//   int rate = 2*iflag -1;
//   int init = end - rate;
//   
//   for(int i=init ; i<=end; i+=rate)
//    {
//      for(int intv= 0; intv<3; ++intv){
//      val[intv] = val[intv]*cc + ld[i][intv];
//      }
//      count = count*exp;
//   }
//    val = val*exp;
// 
// };
// 
// dvector1D FFD_Ext::VSEvaluator(LATTICE<3,4> & lattice, dvector1D & coord)
// {
//  	dvector1D val(3,0.0);
// 	dvector2D temp2, work;
// 
// 	// start of De Casteljau algorithm........................................................
// 	work.resize(lattice.n[0]+1, dvector1D(3, 0.0e0));
// 	temp2.resize(lattice.n_points+1, dvector1D(3,0.e0));
// 
// 	for (int j3=0; j3<=lattice.n[2]; ++j3) //  counting deformation due to every load applied in lattice control points
// 	{
// 		for  (int j2=0; j2<=lattice.n[1]; ++j2)
// 		{
// 			for(int j1=0; j1<= lattice.n[0]; ++j1)
// 			{
// 
// 				int i_l = j3*(lattice.n[0] + 1)*(lattice.n[1]+1) + j2*(lattice.n[0]+1) + j1;
// 				// store loads on x points in temporary matrix work
// 				for(int intv=0; intv<3; intv++) work[j1][intv] = lattice.points[i_l].load[intv];
// 			}// next j1
// 
// 			// call to function BernCast -> obtain partial local deformations
// 			//on grid nz_lattice*nylattice, with fixed quote x=coord[0]
// 			BernVS(lattice.n[0], work, coord[0],val);
// 			temp2[j3*(lattice.n[1]+1) + j2] = val;
// 
// 		}// next j2
// 	}// next j3
// 
// 	// reducing the 2D lattice grid in 1D grid, with constant y=coord[1] and,
// 	// whenever defined by Dim, z = coord[2]..................
// 	freeContainer(work);
// 	work.resize(lattice.n[1]+1,dvector1D(3, 0.0e0));
// 
// 	for (int j2 = 0; j2<= lattice.n[2]; ++j2) //  counting deformation due to every load applied in lattice control points
// 	{
// 		for  (int j1 = 0; j1<=lattice.n[1]; ++j1)
// 		{
// 			int i_l = j2*(lattice.n[1] + 1) + j1;
// 			// store loads on y points in temporary matrix work
// 			work[j1] = temp2[i_l];
// 		}// next j1
// 
// 		// call to function BernCast -> obtain partial local deformations on grid nx_lattice,
// 		//with fixed widht y=coord[1] and, whenever defined by Dim,  with fixed quote z=coord[2]
// 		BernVS(lattice.n[1], work, coord[1],val);
// 
// 		temp2[j2] = val;
// 
// 	} //next j1
// 
// 	// reducing the 1D lattice grid in desidered value, with constantx=coord[0],
// 	// y=coord[1] and, whenever defined by Dim, z = coord[2]..................
// 	freeContainer(work);
// 	work.resize(lattice.n[2]+1, dvector1D(3, 0.0e0));
// 	for  (int j1 = 0; j1<=lattice.n[2]; ++j1)
// 	{
// 		int i_l = j1;
// 		// store loads on x points in temporary matrix work
// 		work[j1] = temp2[i_l];
// 	}// next j1
// 
// 	BernVS(lattice.n[2], work, coord[2], val);
// 
// 	return (val);
// }







// end of libRA_FFD.cpp



 




// coding of libRA_GEODESIC library
#include "libRA_GEODESIC.hpp"

VTK_SM_CLOUD::VTK_SM_CLOUD():VTK_UnstructuredGrid<VTK_SM_CLOUD>()
{
	points = NULL;
};

VTK_SM_CLOUD::VTK_SM_CLOUD( std::string dir_, std::string name_, std::string cod_, int nP_):
								VTK_UnstructuredGrid<VTK_SM_CLOUD>(dir_, name_)

{

	SetCodex(cod_);
	SetDimensions(nP_, nP_, nP_);
	points=NULL;
};

VTK_SM_CLOUD::~VTK_SM_CLOUD()
{
	points=NULL;
};

void VTK_SM_CLOUD::linkData(dvector2D & pp)
{
	points = &pp;

	//check data connection to vtk instatiated info and repair it.

	if(pp.size() != nr_points){

	SetDimensions( pp.size(), pp.size(), pp.size());
	}

};

void VTK_SM_CLOUD::unlinkData()
{
	points=NULL;
};

void VTK_SM_CLOUD::Flush(  fstream &str, string codex_, string name  )
{
	int n;
	 if(points == NULL ){std::cout<<"not linked Data Structure"<<endl; return;}

	  string indent("         ") ;

	    if( codex_ == "ascii"){

	      if( name == "Points" ){
	        for( n=0; n<points->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, 3, (*points)[n]);
	          str << endl ;
	        };
	      };

	      if( name == "connectivity" ){
	        for( n=0; n<points->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, n) ;
	          str << endl ;
	        };
	      };

	      if( name == "types" ){
	        int type_(1) ;
	        for( n=0; n<points->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, type_  ) ;
	          str << endl ;
	        };
	      };

	      if( name == "offsets" ){
	        int off_(0) ;
	        for( n=0; n<points->size(); n++) {
	          off_ += NumberOfElements( 1 ) ;
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, off_  ) ;
	          str << endl ;
	        };
	      };

	    }

	    else{

	    	if( name == "Points" ){
	    		for( n=0; n<points->size(); n++) {
	    			flush_binary( str, (*points)[n]);
	    		 };
	        };

	    	if( name == "connectivity" ){
	    		for( n=0; n<points->size(); n++) {
	    		    flush_binary( str, n) ;
	    		   };
	    	};

	    	if( name == "types" ){
	    	int type_(1) ;
	    		for( n=0; n<points->size(); n++) {
	    		    flush_binary( str, type_  ) ;
	    		};
	    	};

	    	if( name == "offsets" ){
	    	int off_(0) ;
	    	     for( n=0; n<points->size(); n++) {
	    		     off_ += NumberOfElements( 1 ) ;
	    		     flush_binary( str, off_  ) ;
	    		    };
	         };


	      }

	  return ;

};

VTK_SM_CURVE::VTK_SM_CURVE():VTK_UnstructuredGrid<VTK_SM_CURVE>()
{
	curve = NULL;
};

VTK_SM_CURVE::VTK_SM_CURVE( Class_SurfTri & triP, std::string dir_, std::string name_, std::string cod_):
								VTK_UnstructuredGrid<VTK_SM_CURVE>(dir_, name_)

{
	SetCodex(cod_);
	SetDimensions(triP.nSimplex, triP.nVertex, 2*triP.nSimplex);
	curve=&triP;
};

VTK_SM_CURVE::VTK_SM_CURVE(Class_SurfTri & triP, std::string filename_) :
										VTK_UnstructuredGrid<VTK_SM_CURVE>(){
	curve = &triP;

	std::string key1 = "/\\";
	std::string key2 = ".";
	std::size_t cut1 =filename_.find_last_of(key1);
	std::size_t cut2 =filename_.rfind(key2);

	std::string dir, name;
	dir  = filename_.substr(0, cut1);
	name = filename_.substr(cut1+1, cut2-cut1-1);

	SetNames(dir, name);
};

VTK_SM_CURVE::~VTK_SM_CURVE()
{
	curve=NULL;
};

void VTK_SM_CURVE::linkData(Class_SurfTri & triP)
{
	curve = &triP;
};

void VTK_SM_CURVE::unlinkData()
{
	curve=NULL;
};

void VTK_SM_CURVE::Flush(  fstream &str, string codex_, string name  )
{
	int n;
	 if(curve == NULL ){std::cout<<"not linked Data Structure"<<endl; return;}

	  string indent("         ") ;

	    if( codex_ == "ascii"){

	      if( name == "Points" ){
	        for( n=0; n<curve->nVertex; n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, 3, curve->Vertex[n]) ;
	          str<<endl;
	        };

	      };

	      if( name == "connectivity" ){
	        for( n=0; n<curve->nSimplex; n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, 2, curve->Simplex[n]) ;
	          str<<endl;
	        };
	      };

	      if( name == "types" ){
	        int type_(3) ;
	        for( n=0; n<curve->nSimplex; n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, type_  ) ;
	          str<<endl;
	        };
	      };

	      if( name == "offsets" ){
	        int off_(0) ;
	        for( n=0; n<curve->nSimplex; n++) {
	          off_ += NumberOfElements( 3 ) ;
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, off_  ) ;
	          str<<endl;
	        };
	      };

	    }

	    else{

	      if( name == "Points" ){
	        for( n=0; n<curve->nVertex; n++) {
	        	flush_binary( str, curve->Vertex[n]) ;
	        }
	      };

	      if( name == "connectivity" ){
	        for( n=0; n<curve->nSimplex; n++) {flush_binary( str, curve->Simplex[n]);}
	      };

	      if( name == "types"){
	        int type_(3) ;
	        for( n=0; n<curve->nSimplex; n++) flush_binary( str, type_  ) ;
	      };

	      if( name == "offsets"){
	        int off_(0) ;
	        for( n=0; n<curve->nSimplex; n++) {
	          off_ += NumberOfElements( 3 ) ;
	          flush_binary( str, off_  ) ;
	        };
	      };

	      }

	  return ;
};

//Constructor
SupportMesh::SupportMesh( )    // class constructor
{
	name="";
	levelset="HEAT";
	heatTime =1.0;
	levelSetCalc=false;
};

//Destructor
SupportMesh::~SupportMesh( )// class destructor
{
	cleanSupport();
	cleanSDF();

}//end destructor

SupportMesh::SupportMesh(const SupportMesh & other){

    name = other.name;
    Daughter.nVertex  = other.Daughter.nVertex;
    Daughter.nSimplex = other.Daughter.nSimplex;
    Daughter.ResizeVertex();
    Daughter.ResizeSimplex();
    for(int i=0; i<Daughter.nVertex; ++i){
    	Daughter.Vertex[i] = other.Daughter.Vertex[i];
    }
    for(int i=0; i<Daughter.nSimplex; ++i){
        	Daughter.Simplex[i] = other.Daughter.Simplex[i];
    }

    SDFheat.resize(other.SDFheat.size());
    SDFheat = other.SDFheat;

    SDFTri.resize(other.SDFTri.size());
    SDFTri = other.SDFTri;

    {int size = other.SDFGrad.size();
     SDFGrad.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 SDFGrad[i] = other.SDFGrad[i];
     }
    }

    {int size = other.AdjacencyVV.size();
     AdjacencyVV.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVV[i].resize(other.AdjacencyVV[i].size());
    	 AdjacencyVV[i]=other.AdjacencyVV[i];
     }
    }

    {int size = other.AdjacencyVT.size();
     AdjacencyVT.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVT[i].resize(other.AdjacencyVT[i].size());
    	 AdjacencyVT[i]=other.AdjacencyVT[i];
     }
    }

    {int size = other.inverseConn.size();
     inverseConn.resize(size);
     for(int i=0; i<size; ++i){
    	 inverseConn[i].resize(other.inverseConn[i].size());
    	 inverseConn[i]=other.inverseConn[i];
     }
    }

    initialVertexFront.resize(other.initialVertexFront.size());
    initialVertexFront = other.initialVertexFront;

    boundaryFront.resize(other.boundaryFront.size());
    boundaryFront = other.boundaryFront;

    currentSelection.resize(other.currentSelection.size());
    currentSelection = other.currentSelection;

    mapMotherV.resize(other.mapMotherV.size());
    mapMotherV = other.mapMotherV;

    simArea.resize(other.simArea.size());
    simArea  = other.simArea ;

    VoronoiDiag.resize(other.VoronoiDiag.size());
    VoronoiDiag = other.VoronoiDiag;

    {int size = other.cotangentList.size();
    cotangentList.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 cotangentList[i] = other.cotangentList[i];
     }
    }

    levelset = other.levelset;
    heatTime = other.heatTime;
    levelSetCalc = other.levelSetCalc;

}


SupportMesh& SupportMesh::operator=(const SupportMesh  & other)
{
    name = other.name;
    Daughter.nVertex  = other.Daughter.nVertex;
    Daughter.nSimplex = other.Daughter.nSimplex;
    Daughter.ResizeVertex();
    Daughter.ResizeSimplex();
    for(int i=0; i<Daughter.nVertex; ++i){
    	Daughter.Vertex[i] = other.Daughter.Vertex[i];
    }
    for(int i=0; i<Daughter.nSimplex; ++i){
        	Daughter.Simplex[i] = other.Daughter.Simplex[i];
    }

    SDFheat.resize(other.SDFheat.size());
    SDFheat = other.SDFheat;

    SDFTri.resize(other.SDFTri.size());
    SDFTri = other.SDFTri;

    {int size = other.SDFGrad.size();
     SDFGrad.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 SDFGrad[i] = other.SDFGrad[i];
     }
    }

    {int size = other.AdjacencyVV.size();
     AdjacencyVV.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVV[i].resize(other.AdjacencyVV[i].size());
    	 AdjacencyVV[i]=other.AdjacencyVV[i];
     }
    }

    {int size = other.AdjacencyVT.size();
     AdjacencyVT.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVT[i].resize(other.AdjacencyVT[i].size());
    	 AdjacencyVT[i]=other.AdjacencyVT[i];
     }
    }

    {int size = other.inverseConn.size();
     inverseConn.resize(size);
     for(int i=0; i<size; ++i){
    	 inverseConn[i].resize(other.inverseConn[i].size());
    	 inverseConn[i]=other.inverseConn[i];
     }
    }

    initialVertexFront.resize(other.initialVertexFront.size());
    initialVertexFront = other.initialVertexFront;

    boundaryFront.resize(other.boundaryFront.size());
    boundaryFront = other.boundaryFront;

    currentSelection.resize(other.currentSelection.size());
    currentSelection = other.currentSelection;

    mapMotherV.resize(other.mapMotherV.size());
    mapMotherV = other.mapMotherV;

    simArea.resize(other.simArea.size());
    simArea  = other.simArea ;

    VoronoiDiag.resize(other.VoronoiDiag.size());
    VoronoiDiag = other.VoronoiDiag;

    {int size = other.cotangentList.size();
    cotangentList.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 cotangentList[i] = other.cotangentList[i];
     }
    }

    levelset = other.levelset;
    heatTime = other.heatTime;
    levelSetCalc = other.levelSetCalc;

return(*this);
}

void SupportMesh::buildSupport(SHAPE & shape, ivector1D & markedTria, bool & iCheck)
{//extract with a local numeration of vertex and simplex
	//then, cleaning the double vertex, and refresh the vertex map connecting to Mother Mesh Shape.

	ivector1D cleaningMap;
	ivector1D locTri(3,0);
	dvector1D coordV(3,0.0);

	currentSelection.resize(markedTria.size());
	currentSelection = markedTria;
	Daughter.nSimplex = markedTria.size();
	Daughter.nVertex  = 3*markedTria.size();	

	Daughter.ResizeSimplex();
	Daughter.ResizeVertex();
	mapMotherV.resize(Daughter.nVertex);

	int mT_size = markedTria.size();

	for (int nT = 0; nT<mT_size; nT++)
	{
		for (int iLoc=0; iLoc<3; iLoc++)
		{
			coordV = conVect(shape.Vertex[shape.Simplex[markedTria[nT]][iLoc]]);
			Daughter.Vertex[3*nT + iLoc] = conArray<double,3>(coordV);
			mapMotherV[3*nT + iLoc] = shape.Simplex[markedTria[nT]][iLoc] ;
		}//next iLoc

		locTri[0] = 3*nT; locTri[1] = 3*nT+1; locTri[2] = 3*nT+2;
		Daughter.Simplex[nT] = locTri;
	}; //next nT

	//cleaning and generating Normals & Adjacency

	Daughter.RemoveDoubleVertex(cleaningMap);
	Daughter.RemapPointData(cleaningMap, mapMotherV);
	Daughter.ResizeVertex();


	if(Daughter.Normal.size() == 0) Daughter.GenerateNormals();
	else Daughter.ResizeNormal();

	Daughter.FixNodeNumb();
	Daughter.BuildAdjacency();

	cleanCornerNodes();

	//evaluate the inverse connectivity map
	freeContainer(inverseConn);
	inverseConn.resize(Daughter.nVertex);

	for (int iT = 0; iT < Daughter.nSimplex; ++iT) {
		for (int locV = 0; locV < 3; ++locV) {
			inverseConn[Daughter.Simplex[iT][locV]].push_back(iT);
		} //next local indices locV;
	} //next triangle iT;

	double limitFrontRegularization  = 0.0;

	iCheck = true;
	//initialize the support(calculating SDF)
	//calculate adjacency VV e VT and preinitialize the support's frontier
	boundaryFront = vertCalculateAdjacency(iCheck);
	if(!iCheck) return;

	//refine support frontier and initialize SDFTri
	initializeFront(shape, boundaryFront, limitFrontRegularization);

};//end of buildSupport

void SupportMesh::buildSupportEurogen(SHAPE & shape, ivector1D & markedTria, bool & iCheck ){

	buildSupport(shape, markedTria, iCheck);
	if(!iCheck) return;

	//eliminating caps
	int nPatch=0;
	ivector1D flagpatch(Daughter.nSimplex,-1);
	int index0 = -1;
	double toll = 0.8;
	Daughter.PatchDecompose(nPatch, flagpatch, index0,toll);

	ivector2D chosenPatch(nPatch, ivector1D(flagpatch.size(), -1));
	int candidatePatch=-1;

	{
		int j, k, counter;
		int maxsize = 0;
		for(k=0; k<nPatch; ++k){
			counter=0;
			for(j=0; j<Daughter.nSimplex; ++j){
				if(flagpatch[j]==k){
					chosenPatch[k][counter] = j;
					++counter;
				}
			}
			chosenPatch[k].resize(counter);
			if(counter > maxsize){
				maxsize=counter;
				candidatePatch=k;
			}
		}
	}

	ivector1D listOff(Daughter.nSimplex);
	{ int countOff=0;
		//reset Daughter to the max number of patches.
		for(int k=0; k<nPatch; ++k)
		{
			if(k != candidatePatch){
				for(int j=0; j<chosenPatch[k].size(); ++j){
					listOff[countOff]= chosenPatch[k][j];
					++countOff;
				}
			}
		}
		listOff.resize(countOff);
	}


	{
		ivector1D cleaningMap;
		Daughter.RemoveSimplex(listOff, cleaningMap);
		Daughter.RemapCellData(cleaningMap, currentSelection);

		ivector1D cleaningVV;
		Daughter.RemoveIsolatedVertex(cleaningVV);
		Daughter.RemapPointData(cleaningVV,mapMotherV);
	}

	Daughter.ResizeVertex();
	Daughter.ResizeSimplex();
	Daughter.ResizeAdjacency();

	if(Daughter.Normal.size() == 0) Daughter.GenerateNormals();
	else Daughter.ResizeNormal();


	cleanCornerNodes();

	Daughter.FixNodeNumb();

	//evaluate the inverse connectivity map
			freeContainer(inverseConn);
			inverseConn.resize(Daughter.nVertex);

	for (int iT = 0; iT < Daughter.nSimplex; ++iT) {
		for (int locV = 0; locV < 3; ++locV) {
			inverseConn[Daughter.Simplex[iT][locV]].push_back(iT);
		} //next local indices locV;
	} //next triangle iT;

	double limitFrontRegularization  = 0.0;

	iCheck = true;
	//initialize the support(calculating SDF)

	//clean adjacencies and boundary front
	freeContainer(AdjacencyVV);
	freeContainer(AdjacencyVT);
	freeContainer(boundaryFront);

	//calculate adjacency VV e VT and preinitialize the support's frontier
	boundaryFront = vertCalculateAdjacency(iCheck);
	if(!iCheck) return;

	//refine support frontier and initialize SDFTri
	initializeFront(shape, boundaryFront, limitFrontRegularization);

}//end of eurogenbuildsupport

//methods
void   SupportMesh::prepareSupport(std::string& typeFilter, double &heatTime, bool &iCheck)
{
	iCheck=true;
	double time;

	if(typeFilter == "GEODESIC") //Geodesic filtering
	{
		//calculate geodesic SDFTri via Fast Marching algorithm
		eikonal::triangulation::Eikonal2DTriSolve(&Daughter, &inverseConn, SDFTri, SDFGrad, 1.0, 1.0);
		heatTime =1.0;
		time = -1.0;
	}

	else //HEat
	{

		//compute Voronoi diagram on triangulation
		voronoiEF(VoronoiDiag);

		double sumArea = 0.0;
		for (int k = 0; k<Daughter.nSimplex; k++)
		{
			sumArea += simArea[k];
		}//next k

		sumArea = sumArea/Daughter.nSimplex;
		time = heatTime*sumArea;
		double tolPGMRES = sumArea/1.e2;

		HeatSolveEFSparse(time, tolPGMRES);
	}

	//Normalize SDF

	//find Maximum Value of SDF
	double SDFMax = 0.0;
	int SDFTri_size = SDFTri.size();
	for(int i=0; i<SDFTri_size; i++)
	{
		SDFMax = fmax(SDFMax,abs(SDFTri[i]));
	}

	//NORMALIZE
	for(int i=0; i<SDFTri_size; i++){ SDFTri[i] = SDFTri[i]/SDFMax;}

	std::cout<<"********************************************************"<<endl;
	std::cout<<"Maximum distance found on support  " << SDFMax<<endl;
	std::cout<<"Basic square step size h^2 	       " << time/heatTime<<endl;
	std::cout<<"Time step 			       " << time<<endl;
	std::cout<<"********************************************************"<<endl;


	ivector1D deadList = extractDeadVList();
	bool wholeCheck = (SDFMax>=1.e18 && deadList.size()!=0);
	bool nanCheck = std::isnan(SDFMax);
	bool minCheck = (SDFMax < 0.0);
	bool totCheck = wholeCheck + nanCheck + minCheck;
	if (totCheck) iCheck = false;
	levelSetCalc=true;

};//end of prepareSupport

//methods
void   SupportMesh::prepareSupportEurogen(bool & iCheck)
{
	iCheck=true;
	double time;

 	//compute Voronoi diagram on triangulation
	voronoiEF(VoronoiDiag);

	double sumArea = 0.0;
	for (int k = 0; k<Daughter.nSimplex; k++)
	{
			sumArea += simArea[k];
	}//next k

	time = sumArea;
	double tolPGMRES = sumArea/1.e2;

	HeatSolveEFSparse(time, tolPGMRES);

	//Normalize SDF

	//find Maximum Value of SDF
	double SDFMax = 0.0;
	int SDFTri_size = SDFTri.size();
	for(int i=0; i<SDFTri_size; i++)
	{
		SDFMax = fmax(SDFMax,abs(SDFTri[i]));
	}

	//NORMALIZE
	for(int i=0; i<SDFTri_size; i++){ SDFTri[i] = SDFTri[i]/SDFMax;}

	std::cout<<"********************************************************"<<endl;
	std::cout<<"Maximum distance found on support  " << SDFMax<<endl;
	std::cout<<"Basic square step size h^2 	       " << time/heatTime<<endl;
	std::cout<<"Time step 			       " << time<<endl;
	std::cout<<"********************************************************"<<endl;

	ivector1D deadList = extractDeadVList();

	bool wholeCheck = (SDFMax>=1.e18 && deadList.size()!=0);
	bool nanCheck = std::isnan(SDFMax);
	bool minCheck = (SDFMax < 0.0);
	bool totCheck = wholeCheck + nanCheck + minCheck;
	if (totCheck) iCheck = false;
	levelSetCalc=true;

};//end of prepareSupport


void SupportMesh::cleanSDF()
{
	freeContainer(SDFTri);
	freeContainer(SDFGrad);
	freeContainer(AdjacencyVV);
	freeContainer(AdjacencyVT);
	freeContainer(initialVertexFront);
	freeContainer(boundaryFront);
	freeContainer(simArea);
	freeContainer(VoronoiDiag);
	freeContainer(cotangentList);
	levelset="HEAT";
	heatTime=1.0;
	levelSetCalc=false;
} //exit cleanSDF()

void SupportMesh::cleanSupport()
{

	name ="";
	freeContainer(currentSelection);
	freeContainer(mapMotherV);
	Daughter.nVertex = 0;
	Daughter.nSimplex = 0;
	Daughter.nEdge = 0;

	// Destroy variables
	freeContainer(Daughter.Vertex);
	freeContainer(Daughter.Simplex);
	freeContainer(Daughter.Normal);
	freeContainer(Daughter.Adjacency);
	freeContainer(Daughter.Edge);
	freeContainer(Daughter.Simplex2Edge);
	freeContainer(Daughter.ENormal);
	freeContainer(Daughter.VNormal);
} //exit cleanSupport()

//private methods
void  SupportMesh::cleanCornerNodes()
{ //clean automatically corner nodes and corner simplicies associated to it

	ivector1D bmap = Daughter.FindFreeSimplex();
	ivector1D cornerList(bmap.size(),0);
	int counter = 0;
	int bmap_size= bmap.size();
	for (int i=0; i<bmap_size; i++)
	{
		int count = 0;
		for(int j=0; j<3; j++) {if(Daughter.Adjacency[bmap[i]][j][0] == -1) count++;}
		if(count > 1) {cornerList[counter] = bmap[i]; counter++;}
	}//next i

	cornerList.resize(counter);

	if(cornerList.size() > 0){

	ivector1D cleanSim;
	Daughter.RemoveSimplex(cornerList,cleanSim);
	Daughter.RemapCellData(cleanSim,currentSelection);

	ivector1D cleanMap;
	Daughter.RemoveIsolatedVertex(cleanMap);
	Daughter.RemapPointData(cleanMap, mapMotherV);

	Daughter.ResizeVertex();
	Daughter.ResizeSimplex();
	Daughter.ResizeNormal();
	Daughter.ResizeAdjacency();

	//refresh inverseconnectivity
	//evaluate the inverse connectivity map
	freeContainer(inverseConn);
	inverseConn.resize(Daughter.nVertex);

	for (int iT = 0; iT < Daughter.nSimplex; ++iT) {
		for (int locV = 0; locV < 3; ++locV) {
			inverseConn[Daughter.Simplex[iT][locV]].push_back(iT);
		} //next local indices locV;
	} //next triangle iT;

	}
}//end of cleanCornerNodes

ivector1D SupportMesh::vertCalculateAdjacency(bool & iCheck)
{// set Adjacency Vertex-Vertex and store it in AdjacencyVV.
	// Meanwhile marks all boundary vertexes and store it in a temporary	vector

	ivector1D tempMarkedVert;
	bool checkRing = true;

	AdjacencyVV.resize(Daughter.Vertex.size()); //????
	AdjacencyVT.resize(Daughter.Vertex.size());

	//almighty loop on Simplex
	for(int nT=0; nT < Daughter.nSimplex; nT++)
	{
		for (int ilocV=0; ilocV<3; ilocV++)
		{
			ivector1D simplexList;
			bool flag;

			int iVert = Daughter.Simplex[nT][ilocV];

			if (AdjacencyVV[iVert].size() == 0 && AdjacencyVT[iVert].size()==0 )
			{
				//finding 1-Ring
				simplexList = Daughter.Ring_1(nT, ilocV,flag, checkRing);
				if(!checkRing) {
					iCheck = checkRing;
					return(tempMarkedVert);
				}
				//store simplex in AdjacencyVT
				AdjacencyVT[iVert].resize(simplexList.size(),0);
				AdjacencyVT[iVert] = simplexList;

				ivector1D work;
				map<int, int> map_vertex;
				//looping on SimplexRing
				int simplexlist_size= simplexList.size();
				for (int nTring = 0; nTring<simplexlist_size ; nTring++)
				{

					for(int vLoc = 0; vLoc<3; vLoc++)
					{
						int iVneigh = Daughter.Simplex[simplexList[nTring]][vLoc];

						if(iVneigh != iVert) work.push_back(iVneigh);

					}//next vLoc
				}//next nTring

				// remove duplicate vertex via map iterator
				int work_size = work.size();
				for (int k = 0; k<work_size; k++){map_vertex[work[k]] = work[k];}
				// transfer information in the  AdjacencyVV
				AdjacencyVV[iVert].resize(map_vertex.size());
				int counter = 0;
				for(map<int,int>::iterator it_map_vertex = map_vertex.begin(); it_map_vertex !=map_vertex.end(); it_map_vertex++)
				{
					AdjacencyVV[iVert][counter] = (*it_map_vertex).second;
					counter++;
				}

				//filling infos on boundary nodes
				if(!flag){tempMarkedVert.push_back(iVert);}

			}//endif looping on 1Ring_simplex

		}//next ilocV
	}//next nT


	return(tempMarkedVert);

}; //end of vertCalculateAdjacency

void  SupportMesh::initializeFront(SHAPE & shape, vector<int> & tempMV, double & limit)
{// select boundary nodes of the patch, exclude those belonging to
	// free edges in the Mother triangulation SHAPE, initialize the front
	// for FastMarching(stored in initialVertexFront member)

	// boundary of the original tasselation are stored in shape.freeVertFront
	//looping on tempMV, store on Daughter frontier allo those value of tempMV not matching
	// shape FreeVertFront. Global numeration of tempMV is on mapMotherV

	//initialize shape.FreeVertFront

	//store vertex on frontier
	shape.markVertFrontier();

	int tempMV_size = tempMV.size();
	for(int nV=0; nV<tempMV_size; nV++)
	{
		vector<int>::iterator oFront_it;

		oFront_it = find(shape.freeVertFront.begin(), shape.freeVertFront.end(), mapMotherV[tempMV[nV]]);

		if(oFront_it == shape.freeVertFront.end())
		{
			initialVertexFront.push_back(tempMV[nV]);
		}
	} //next nV vertex

	// Initialize SDF

	SDFTri.resize(Daughter.Vertex.size(), 1e+18);
	SDFheat.resize(Daughter.Vertex.size(), 0.0);
	SDFGrad.resize(Daughter.Vertex.size(), dvector1D (3,0.0));


	int iVF_size =  initialVertexFront.size();
	for(int nV=0; nV<iVF_size; nV++)
	{
		SDFTri[initialVertexFront[nV]] = 0.0; //front value of the Fast Marching

	}//next nV

}; //end of initialize front


ivector1D SupportMesh::extractDeadVList()
{//extract those vertices marked as 0 in the member SDFTri

	int SDFTri_size = SDFTri.size();
	int counter=0;
	ivector1D result(SDFTri_size,-1);

	for (int i=0; i<SDFTri_size; ++i)
	{
		if(SDFTri[i] == 0)
		{
			result[counter]=i;
			++counter;
		}
	}//next i

	result.resize(counter);
	return(result);
};//end of extractDeadVList

int   SupportMesh::findPosition(int & targetVal, ivector1D & source)
{// find position of targetVal in source. Returns -1 if targetVal is not found

	int result = -1;

	ivector1D::iterator it = find(source.begin(), source.end(), targetVal);
	if(it != source.end()){
		result = std::distance(source.begin(), it);
	} //endif

	return(result);
}; //findPosition

dvector2D SupportMesh::normGradOnTriangulation( dvector1D & heatSol)
{// calculate normalized gradient of a scalar field heatSol in point data, for every simplex of the triangulation

	dvector2D gradient(Daughter.nSimplex,dvector1D(3,0.0));

	for (int nS = 0; nS<Daughter.nSimplex; nS++)
	{
		dvector2D edgeVec(3,dvector1D(3,0.0));
		dvector2D edgeNorm(3,dvector1D(3,0.0));

		edgeVec[0] = conVect(Daughter.Vertex[Daughter.Simplex[nS][1]] - Daughter.Vertex[Daughter.Simplex[nS][0]]);
		edgeVec[1] = conVect(Daughter.Vertex[Daughter.Simplex[nS][2]] - Daughter.Vertex[Daughter.Simplex[nS][1]]);
		edgeVec[2] = conVect(Daughter.Vertex[Daughter.Simplex[nS][0]] - Daughter.Vertex[Daughter.Simplex[nS][2]]);

		for(int k=0; k<3; k++) edgeNorm[k] = Cross_Product(conVect(Daughter.Normal[nS]), edgeVec[k]);

		gradient[nS] = (heatSol[Daughter.Simplex[nS][2]] * edgeNorm[0]+
				heatSol[Daughter.Simplex[nS][0]] * edgeNorm[1]+
				heatSol[Daughter.Simplex[nS][1]] * edgeNorm[2]) * 0.5/simArea[nS];

		double normG = norm_2(gradient[nS]);

		if(normG == 0.0) std::cout<<"found norm 0 gradient in  " << nS << endl;
		gradient[nS] = -1.0*gradient[nS]/normG;


	}//next nS
	/*	std::cout<< "==============================================" << endl;
			std::cout<< " Gradienti spigolo basso sinistra" <<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[463][i]<<'\t';}
					       std::cout<<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[605][i]<<'\t';}
					       std::cout<<endl;

			std::cout<< "==============================================" << endl;

			std::cout<< "==============================================" << endl;
			std::cout<< " Gradienti spigolo basso destra" <<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[392][i]<<'\t';}
					       std::cout<<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[497][i]<<'\t';}
					       std::cout<<endl;

			std::cout<< "==============================================" << endl;
			std::cout<< "==============================================" << endl;
			std::cout<< " Gradienti spigolo alto destra" <<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[426][i]<<'\t';}
					       std::cout<<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[604][i]<<'\t';}
					       std::cout<<endl;

			std::cout<< "==============================================" << endl;
			std::cout<< "==============================================" << endl;
			std::cout<< " Gradienti spigolo alto sinistra" <<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[534][i]<<'\t';}
					       std::cout<<endl;
			for(int i=0; i<3;i++) {std::cout<<gradient[675][i]<<'\t';}
					       std::cout<<endl;
			std::cout<< "==============================================" << endl;
	 */
	return(gradient);

} //end of normGradOnTriangulation

ivector2D SupportMesh::extractFreeEdges(int & target)
{ //extract free bound triangle indices and their free local edge number for a target node target.
	// Returns a matrix 2x2 , carrying on the first column the index of the triangle, and on the second column the index of hte local edge free

	ivector2D result;
	ivector2D  map (3,ivector1D(2,-1));
	//compiling map

	map[0][0] = 1; map[0][1] = 0;
	map[1][0] = 2; map[1][1] = 1;
	map[2][0] = 0; map[2][1] = 2;

	int avt_size = AdjacencyVT[target].size();

	for(int i=0; i < avt_size; i++)
	{
		int jTr = AdjacencyVT[target][i];

		for(int kEdge=0; kEdge<3; kEdge++)
		{
			if(Daughter.Adjacency[jTr][kEdge][0] == -1)
			{
				ivector1D temp(2,0);
				temp[0] = jTr; temp[1] = kEdge;
				result.push_back(temp);
			}	//endif
		}//next kEdge
	}//next i

	//check errors
	if(result.size() != 2 ) std::cout<< "Errors occured in function SupportMesh::extractFreeEdgesVect.A number of free edges != 2 occured for the boundary vertex "<< target << "     "<<endl;

	return(result);
}//end of extractFreeEdgesVect

dvector1D SupportMesh::localGradTriangle( int & nS, dvector1D & val)
{// calculate gradient of a local scalar field val, ordered as the local numeration of nS vertices, in point data,

	dvector1D gradient(3,0.0);

	dvector2D edgeVec(3,dvector1D(3,0.0));
	dvector2D edgeNorm(3,dvector1D(3,0.0));

	edgeVec[0] = conVect(Daughter.Vertex[Daughter.Simplex[nS][1]] - Daughter.Vertex[Daughter.Simplex[nS][0]]);
	edgeVec[1] = conVect(Daughter.Vertex[Daughter.Simplex[nS][2]] - Daughter.Vertex[Daughter.Simplex[nS][1]]);
	edgeVec[2] = conVect(Daughter.Vertex[Daughter.Simplex[nS][0]] - Daughter.Vertex[Daughter.Simplex[nS][2]]);

	{

	for(int k=0; k<3; k++) edgeNorm[k] = Cross_Product(conVect(Daughter.Normal[nS]), edgeVec[k]);
	}
	gradient = (val[2] * edgeNorm[0]+
			val[0] * edgeNorm[1]+
			val[1] * edgeNorm[2]) * 0.5/simArea[nS];

	return(gradient);

} //end of localGradTriangle

dvector2D SupportMesh::remapTriangleOnPlane(int & nT, dvector2D & refVectors)
{ // given the index of triangle on tasselation, remap its local vertices on its own plane,
	// and returns them, together with the elemental vectors of the local reference system

	dvector2D tVertices(3, dvector1D(2,0.0));
	refVectors.resize(2,dvector1D(3,0.0));

	int V0,V1,V2;
	V0 = Daughter.Simplex[nT][0];
	V1 = Daughter.Simplex[nT][1];
	V2 = Daughter.Simplex[nT][2];


	refVectors[0] = conVect(Daughter.Vertex[V1] - Daughter.Vertex[V0]);

	tVertices[1][0] = norm_2(refVectors[0]);
	refVectors[0] = refVectors[0]/norm_2(refVectors[0]);

	refVectors[1] = Cross_Product(conVect(Daughter.Normal[nT]), refVectors[0]);
	refVectors[1] = refVectors[1]/norm_2(refVectors[1]);

	tVertices[2][0] = Dot_Product(conVect(Daughter.Vertex[V2] - Daughter.Vertex[V0]), refVectors[0]);
	tVertices[2][1] = Dot_Product(conVect(Daughter.Vertex[V2] - Daughter.Vertex[V0]), refVectors[1]);

	return(tVertices);

}//end of remapTriangleOnPlane

dvector1D SupportMesh::pVplane(dvector1D & vect, dvector2D & reference)
{// return the 2D projection of a 3D vector on a plane described by 2 elemental vector of reference

	dvector1D result(2, 0.0);

	for(int i= 0; i<2; i++)
	{
		result[i] = Dot_Product(vect,reference[i]);
	}

	return(result);
}//end of pVplane

dvector2D SupportMesh::evaluateTestFDeriv(int & nT, dvector2D & vertPlanar)
{ //evaluate the derivatives of the three test "Hat" functions, centered on each local node of a triangle.
	// Coordinates of the triangle's vertices must be given in its own planar reference system. Gradient of test 		      functions are returned in such ref frame.


	ivector1D iMap (5,0);
	iMap[1] = 1; iMap[2] = 2; iMap[4] = 1;

	dvector2D result(3,dvector1D(2,0.0));

	for (int i=0; i<3; i++)
	{
		result[i][0] = 0.5* (vertPlanar[iMap[i+1]][1] - vertPlanar[iMap[i+2]][1]) / simArea[nT];
		result[i][1] = 0.5* (vertPlanar[iMap[i+2]][0] - vertPlanar[iMap[i+1]][0]) / simArea[nT];
	}

	return(result);
}//end of evaluateTestFDeriv

double SupportMesh::assemblyIntegral(int & nT, dvector1D &v1, dvector1D & v2)
{// assembly the Integral of Dot Product of v1 and v2 on simplex nT, in planar ref system

	double result;
	result = Dot_Product(v1,v2) * simArea[nT];
	return (result);

}//end of assemblyIntegral

dvector1D SupportMesh::quadratureDivergence(dvector2D & gradient)
{// calculate the integral of the product between the normalized gradient of the heat solution and
	//the test function gradient, over the 1-ring of the test function.

	dvector1D rhs(Daughter.nVertex, 0.0);


	for ( int iT = 0; iT< Daughter.nSimplex; iT++)
	{
		dvector2D refSys, Vert;
		Vert = remapTriangleOnPlane(iT,refSys);
		dvector1D gradX = pVplane(gradient[iT], refSys);
		dvector2D gradPhi = evaluateTestFDeriv(iT,Vert);

		for(int locV = 0; locV<3; locV++)
		{
			int iV  = Daughter.Simplex[iT][locV];

			rhs[iV] = rhs[iV] + assemblyIntegral(iT, gradPhi[locV], gradX);
		}//next locV

	}//next iT

	return(rhs);  
}//end of quadratureDivergence

void    SupportMesh::voronoiEF(dvector1D & vorV)
{//evaluate the integrals of the Hat test function on the 1-ring of each node of the tasselation.

	simArea.resize(Daughter.nSimplex,0.0);
	for(int k=0; k<Daughter.nSimplex; ++k){
		simArea[k] = Daughter.Area(k);
	}

	vorV.resize(Daughter.nVertex,0.0);

	for (int iV= 0; iV<Daughter.nVertex; iV++)
	{
		for (int iTri = 0; iTri< AdjacencyVT[iV].size(); iTri++)
		{
			int locT = AdjacencyVT[iV][iTri];

			vorV[iV] = vorV[iV] + simArea[locT]/3.0;

		}//next iTri
	}//next iV

} //end of voronoiEF

dvector1D SupportMesh::jacobianGradient(int & nT, int & edge)
{ //evaluate the Jacobian of the linear expression Grad (U) * normal_edge on the triangle, for each local vertex

	dvector1D jacobian (3,0.0);
	dvector1D val(3,1.0), val_pert(3,0.0);
	double pert = 0.1;

	//evaluate normal to the edge multiplied by its edge length.

	int edge_max = edge + 1; if(edge_max >2) edge_max = 0;
	int I = Daughter.Simplex[nT][edge];
	int J = Daughter.Simplex[nT][edge_max];

	dvector1D vecEdge(3,0.0), normal(3,0.0);

	vecEdge = conVect(Daughter.Vertex[J] - Daughter.Vertex[I]);
	normal  = Cross_Product(conVect(Daughter.Normal[nT]), vecEdge);

	double original = 0.5*Dot_Product(localGradTriangle(nT, val), normal);

	val_pert = val;
	for(int i=0; i<3; i++)
	{
		val_pert[i] += pert;

		dvector1D grad = localGradTriangle(nT, val_pert);

		jacobian[i] = (0.5*Dot_Product(grad, normal) - original)/pert;

		val_pert[i] = val[i];
	}

	return(jacobian);

}


double * SupportMesh::bulkMassMatrixSparse(int & nDimension, int *& jA, int *& iA )
{ //evaluate the mass matrix, and store it in sparse CSR format.
	// returns matrix compressed as default output, column Vector jA and row Vector iA as standard short int array


	ivector1D deadList(boundaryFront.size(), 0);
	deadList = boundaryFront;

	ivector1D SimplexList;

	int nDim = Daughter.nVertex;

	dvector1D matrix;
	ivector1D jcolumn;

	//allocate directly row ordering iA in an array structures
	iA = new int[nDim +1]();
	//starting with the initial value of iA
	nDimension = 0;
	iA[0] = 0;


	for(int nV = 0; nV<Daughter.nVertex; nV++) //looping on vertices
	{
		//ordering and save the 1ring map of neighbours of nV, itself included
		map<int,int> mapIndex;
		mapIndex[nV] = nV;
		for(int k=0; k<AdjacencyVV[nV].size(); k++) mapIndex[AdjacencyVV[nV][k]] = AdjacencyVV[nV][k];
		//save ordered map in a ivector1D list
		ivector1D listNode;
		for(map<int,int>::iterator it_map= mapIndex.begin(); it_map !=mapIndex.end(); it_map++)
		{
			listNode.push_back((*it_map).second);
		}
		dvector1D rowNv(listNode.size(), 0.0);

		int avt_size= AdjacencyVT[nV].size();
		for (int nTi= 0; nTi < avt_size; nTi++) //looping on simplex 1Ring of vertex nV
		{
			int nT = AdjacencyVT[nV][nTi];
			dvector2D reference;
			dvector2D VertT   = remapTriangleOnPlane(nT, reference);
			dvector2D gradPhi = evaluateTestFDeriv(nT, VertT);

			int i_nV = findPosition (nV,Daughter.Simplex[nT]);
			for(int j=0; j<3; j++)
			{
				int locMap = findPosition(Daughter.Simplex[nT][j], listNode);
				rowNv[locMap] += assemblyIntegral(nT, gradPhi[i_nV], gradPhi[j]);
			} //next j
		}//next nTi

		int rowNv_size = rowNv.size();
		for(int ks=0; ks<rowNv_size; ks++)
		{
			matrix.push_back(rowNv[ks]);
			jcolumn.push_back(listNode[ks]); // Warning! When saved in jA, value of listNode must be incremented by 1 due to Sparskit fortran convention;
		}
		nDimension+= listNode.size();
		iA[nV+1] = nDimension ;
	}//next nV

	// allocate the static structures and fill them with vector results

	double * Lpmat= new double[nDimension]();
	jA   = new int[nDimension]();

	for(int i=0; i<nDimension;  i++)
	{
		Lpmat[i] = matrix[i];
		jA[i]    = jcolumn[i];
	}

	return(Lpmat);
}//end of bulkMassMatrix


void  SupportMesh::heatMatrixSparse(double * Tdmat, double * Lpmat, int * jA, int * iA, double & time, double & alphaBC)
{//instantiate the Heat matrix with symmetry boundary condition, whenever a Dirichlet is not enforced by a flag true. iA, jA of CSR Lpmat are indexed in fortran convention (from 1 to nDimension and NOT from 0 to nDimension
	// CHANGED: the flag no longer exists: a double, i.e. alphaBC, has been added in order to introduce a Robin boundary condition (weighted combination of Dirichlet and Neumann).

	ivector1D deadList = extractDeadVList();
	int nDim = Daughter.nVertex;
	double alpha;

	// check alpha values
	if(alphaBC<0){
		alpha=0.0;	// a<0.0 -> Dirichlet
	}
	else if(alphaBC>1){
		alpha=1.0;	// a>1.0 -> Neumann
	}
	else {
		alpha=alphaBC;	// Robin (!*)
	}


	for (int i=0; i<nDim; i++){

		ivector1D::iterator it_n = find(boundaryFront.begin(), boundaryFront.end(), i);

		if(it_n == boundaryFront.end()){ // internal nodes

			for(int j=iA[i]; j<iA[i+1]; j++)Tdmat[j] = time*Lpmat[j]; //selected row of ith-node

			int jtarget = findCSRPosition (i , i, jA, iA);
			Tdmat [jtarget] += VoronoiDiag[i];}

		else { // nodes belonging to boundary front

			ivector1D::iterator it_d = find(deadList.begin(), deadList.end(), i);

			int jtarget = findCSRPosition(i,i,jA,iA);
			if(it_d != deadList.end()) Tdmat[jtarget] = 1.0; // vinculated nodes -> Dirichlet boundary conditions
			else {						// free nodes  -> user-specified boundary conditions (depending on alpha values)
				for(int k=iA[i]; k<iA[i+1]; k++)Tdmat[k] = Lpmat[k]*alpha;
				ivector2D freeEd = extractFreeEdges(i);

				for(int k1=0; k1<2; k1++)
				{
					dvector1D jacobian = jacobianGradient(freeEd[k1][0], freeEd[k1][1]);

					for (int k2=0; k2<3; k2++)
					{
						int J = Daughter.Simplex[freeEd[k1][0]][k2];
						int jtarget = findCSRPosition(i , J, jA, iA);
						Tdmat[jtarget] += -1.0*jacobian[k2]*alpha;
					}//next k2
				}//next k1
				Tdmat[jtarget]+=(1-alpha)*1.0;
			}//end else (vinculated/free nodes)
		}//end else (internal/boundary front nodes)
	}//next i



}//end of heatMatrix


void SupportMesh::HeatSolveEFSparse( double & time, double & toleranceIterative)
{// solving the heat equation to recover a distance path function. Finite elements version
	// three step are provided.
	//	1) solving the implicit heat equation for a certain time, starting from an initial condition of 1 on the dead nodes
	//	2) Recover gradients of the solution on the step 1 and evaluate divergence
	//	3) solving the poisson equation for distance function, with divergence in the step 2 as source term
	//
	//final solution after the step 3 is stored in SDF. SPARSE version
	SuperMatrix A, L, U, B;
	int                 *perm_r; /* row permutations from partial pivoting */
	int                 *perm_c; /* column permutation vector */
	int                 info, permc_spec;

	superlu_options_t   options;
	SuperLUStat_t       stat;


	using namespace std::chrono;
	double *LapMat ;
	double *TDmat, *RHS;
	int *Jmat, *Imat;
	int nLapDim;
	int nDim = Daughter.nVertex;

	dvector1D zeros(nDim,0.0);
	std::cout<< "Characteristic dimension of the Heat Linear System  "<<nDim<<endl;

	steady_clock::time_point t1 = steady_clock::now();
	ivector1D deadList = extractDeadVList();
	if(deadList.size() !=0) {
		LapMat = bulkMassMatrixSparse(nLapDim, Jmat, Imat);


		RHS   = new double[nDim]();
		for (int i=0; i<deadList.size(); i++) {
			RHS[deadList[i]] = -1.0;
		};

		steady_clock::time_point t2 = steady_clock::now();
		duration<double> t1span = duration_cast<duration<double>>(t2-t1);
		std::cout<<"...creating matrices cost me  "<<t1span.count()<<endl;

		// prepare timedependent Matrix TDmat
		ivector1D deadL = extractDeadVList();
		dvector1D solution(nDim, 0.0);

		TDmat = new double[nLapDim]();
		double alphaBC = 1.0; // (1-a)*Dirichlet + a*Neumann
		heatMatrixSparse(TDmat, LapMat, Jmat, Imat, time,  alphaBC);
		//ht TDmat is matrix in sparse format

		steady_clock::time_point t3 = steady_clock::now();
		duration<double> t2span = duration_cast<duration<double>>(t3-t2);
		std::cout<<"...creating heat matrix cost me  "<<t2span.count()<<endl;

		/* Initialize matrix A. */
		//m = n = nDim ;
		//nnz = nLapDim;

		/* Create matrix A in the format expected by SuperLU. */
		dCreate_CompRow_Matrix(&A, nDim, nDim, nLapDim, TDmat, Jmat, Imat, SLU_NR, SLU_D, SLU_GE);

		/* Create right-hand side matrix B. */
		dCreate_Dense_Matrix(&B, nDim, 1, RHS, nDim, SLU_DN, SLU_D, SLU_GE);

		if ( !(perm_r = intMalloc(nDim)) ) ABORT("Malloc fails for perm_r[].");
		if ( !(perm_c = intMalloc(nDim)) ) ABORT("Malloc fails for perm_c[].");

		/* Set the default input options. */
		set_default_options(&options);
		//options.ColPerm = MMD_ATA;//NATURAL;
		options.SymmetricMode=YES;
		/* Initialize the statistics variables. */
		StatInit(&stat);

		/* Solve the linear system. */
		dgssv(&options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);
		std::cout << "exit condition of first linear system " << info << std::endl ;

		for( int i=0; i<nDim; ++i){
			solution[i] = RHS[i] ;
		}

	for (int i=0; i<nDim; i++) {SDFheat[i] = solution[i];}

	Destroy_SuperMatrix_Store(&A);
	Destroy_SuperMatrix_Store(&B);

	Destroy_SuperNode_Matrix(&L);
	Destroy_CompCol_Matrix(&U);

	steady_clock::time_point t4 = steady_clock::now();
	duration<double> t3span = duration_cast<duration<double>>(t4-t3);
	std::cout<<"...solving first system cost me  "<<t3span.count()<<endl;



	//Second step -> gradient and divergence of the solution
	dvector2D GradientNorm = normGradOnTriangulation(solution);
	dvector1D Divergence   = quadratureDivergence(GradientNorm);

	steady_clock::time_point t5 = steady_clock::now();
	duration<double> t4span = duration_cast<duration<double>>(t5-t4);
	std::cout<<"...solving divergence cost me  "<<t4span.count()<<endl;

	//Third Step -> Poisson relaxing Step
	/* Imposing Dirichlet boundary conditions whenever the Dirichlet flag is true */
	//bool Dirichlet= true;
	//if (Dirichlet){
	RHS   = new double[nDim]();
	for (int i=0; i<nDim; i++) RHS[i] = -1.0*Divergence[i];
	for (int i=0; i<deadList.size(); i++) {
		RHS[deadList[i]] = 0.0;
		int jTarg  = findCSRPosition(deadList[i], deadList[i], Jmat, Imat);

		for(int j=Imat[deadList[i]]; j<Imat[deadList[i]+1]; j++)
		{
			LapMat[j]  = 0.0;
		}
		LapMat[jTarg] = 1.0;
	}
	//}
/*else {
				// hanging node choice
				int nCheck1 ;
				bool exitCycle= false;
				int count = 0;

				while (count<Daughter.nVertex && !exitCycle)
				{
					ivector1D::iterator  itCheck = find(boundaryFront.begin(), boundaryFront.end(), count);

					if(itCheck == boundaryFront.end())
					{
						nCheck1 = count;
						exitCycle = true;
					}
					count++;
				}

				int hNode = nCheck1;

				int jTarg  = findCSRPosition(hNode, hNode, Jmat, Imat);

				for(int j=Imat[hNode]; j<Imat[hNode+1]; j++)
				{
					LapMat[j]  = 0.0;
				}

				LapMat[jTarg] = 1.0;

				RHS   = new double[nDim]();
				for (int i=0; i<nDim; i++) RHS[i] = -1.0*Divergence[i];

				//hanged vertex hNode
				RHS[hNode] = 0.0;
			};
			//

	/* Create matrix A in the format expected by SuperLU. */
	dCreate_CompRow_Matrix(&A, nDim, nDim, nLapDim, LapMat, Jmat, Imat, SLU_NR, SLU_D, SLU_GE);

	/* Create right-hand side matrix B. */
	dCreate_Dense_Matrix(&B, nDim, 1, RHS, nDim, SLU_DN, SLU_D, SLU_GE);

	/* Set the default input options. */
	set_default_options(&options);
	options.SymmetricMode=YES;
	//options.ColPerm = MMD_ATA;//NATURAL;

	/* Initialize the statistics variables. */
	StatInit(&stat);

	/* Solve the linear system. */
	dgssv(&options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);
	std::cout << "exit condition of second linear system " << info << std::endl ;

	{ int i;

	for( i=0; i<nDim; ++i){
		solution[i] = RHS[i] ;
	}
	};

	/* De-allocate storage */
	SUPERLU_FREE (perm_r);
	SUPERLU_FREE (perm_c);

	Destroy_SuperMatrix_Store(&A);
	Destroy_SuperMatrix_Store(&B);

	Destroy_SuperNode_Matrix(&L);
	Destroy_CompCol_Matrix(&U);

	steady_clock::time_point t6 = steady_clock::now();
	duration<double> t5span = duration_cast<duration<double>>(t6-t5);
	std::cout<<"...solving second system cost me  "<<t5span.count()<<endl;

	delete [] LapMat; LapMat = NULL ;
	delete [] TDmat; TDmat = NULL ;
	delete [] Imat; Imat = NULL ;
	delete [] Jmat; Jmat = NULL ;
	delete [] RHS; RHS = NULL ;

	//DEBUG  & CHECKS
	//		SDFTri = Divergence;
	for (int i = 0; i<nDim; i++)
	{
		dvector1D sum_mod (3,0.0);
		double sz = AdjacencyVT[i].size();
		for(int nN = 0; nN<AdjacencyVT[i].size(); nN++)
		{
			int j = AdjacencyVT[i][nN];
			sum_mod = sum_mod +  GradientNorm[j] / sz;
		}

		SDFGrad[i] = sum_mod;
	}

	//save solution in SDFtri e release memory

	dvector1D PhiMax;
	ivector1D mapVert = findRefValueOnBoundary(solution, deadL, PhiMax, false);

	for(int kP=0; kP<PhiMax.size(); kP++)
		std::cout<< "maximum positive distance found on boundary of subpatch  "<<kP<<"  is  :  "<< PhiMax[kP]<<endl;
	for (int i=0; i<nDim; i++) {SDFTri[i] = solution[i] - PhiMax[mapVert[i]];}

} //ENDIF DEADLIST NULL;

return ;

}//end of HeatSolveEF


	
	  int SupportMesh::findCSRPosition(int & iD, int & jD, int * jA,  int * iA)
	    {// personal c++ version of getelm_ function of Sparskit

	     int result;	
	     int target = jD ;
	     int * puntBegin = &jA[0]; //pointer to jA begin	
	     	
	     for(int k=iA[iD]; k<iA[iD+1]; k++)
		{
		 if(jA[k] == target)
		   { int * puntFind = &jA[k];
		     result = (puntFind - puntBegin);	 		 
		   }//endif	
		}//next k	
		
		return(result);
		}//end of findCSRPosition


ivector1D SupportMesh::findRefValueOnBoundary(dvector1D & solution, ivector1D & deadList, dvector1D & PhiBound, bool flag)
{//find the max/min (false/true flag) value of a solution vector on the DEAD boundary of the support. If the support
	//is composed by multi sub patches non connected, it finds one value for each sub patch dead boundary

	ivector1D MapVertex(Daughter.nVertex,-1);
	int nPatches=0;
	ivector1D MapPatchSimplex(Daughter.nSimplex, -1);

	//launching loop decompose on the support
	Daughter.LoopDecompose(nPatches, MapPatchSimplex, -1);

	int phi_sign =-1.0; if(flag) phi_sign = 1.0;
	double initVal = phi_sign*1.e18;
	PhiBound.resize(nPatches, initVal);

	//flagging vertex with sub patch belonging int flag

	for (int nT = 0; nT<Daughter.nSimplex; nT++)
	{
		for(int locV = 0; locV<3; locV++)
		{
			int I = Daughter.Simplex[nT][locV];
			if(MapVertex[I] == -1) MapVertex[I] = MapPatchSimplex[nT];
		}//next locV
	}//next nT

	//calculate PhiMax/PhiMin

	for(int k=0; k<deadList.size(); k++)
	{
		int I=deadList[k];

		if(!flag) PhiBound[MapVertex[I]] = fmax(PhiBound[MapVertex[I]], solution[I]);
		else      PhiBound[MapVertex[I]] = fmin(PhiBound[MapVertex[I]], solution[I]);
	}//next k

	return(MapVertex);
} //end of findRefValueonBoundary


void SupportMesh::plotBoundaryFront(std::string dir, std::string name, bool flag){

if(!(boundaryFront.size()>0))
	{
		std::cout<<"Error your tesselation is not correctly initialized in Support Mesh class"<<std::endl;
	}

if(AdjacencyVV.size() == 0 || AdjacencyVT.size() == 0){
	std::cout<<"TriangularMesh Support not Defined. Please defined it first!"<<std::endl;
	exit(1);
}

// Local variables
Class_SurfTri boundaryCurve;
int mapT = boundaryFront.size();
for (int iV = 0; iV < mapT; ++iV) {
	int V = boundaryFront[iV];
	int n = AdjacencyVV[V].size();

	ivector1D trueNeighs(n,-1);
	ivector1D dummy_vec(n,-1);
	int counter=0;
	for(int i=0; i<n; ++i){
		int pos = posVectorFind(boundaryFront, AdjacencyVV[V][i]);
		if(pos != -1){
			trueNeighs[counter]=pos;
			++counter;
		}

	}

	trueNeighs.resize(counter);

	//refine trueNeighs search
	if (counter > 2){

		int countNew=0;
		dummy_vec.resize(counter);
		int nT=AdjacencyVT[V].size();

		for(int iK=0; iK<counter;++iK){
			for(int iT=0; iT<nT; ++iT){

				int pos = posVectorFind(Daughter.Simplex[AdjacencyVT[V][iT]], boundaryFront[trueNeighs[iK]]);

				if(pos !=-1){
					int target = AdjacencyVT[V][iT];
					int locEdge = Daughter.edge(target,V,boundaryFront[trueNeighs[iK]]);
					if(Daughter.Adjacency[target][locEdge][0] == -1){
						dummy_vec[countNew] = trueNeighs[iK];
						++countNew;
					}
				}

			}
		}
		dummy_vec.resize(countNew);
		trueNeighs.resize(countNew);
		trueNeighs = dummy_vec;
		counter = countNew;
	}

	//adding vertex

	boundaryCurve.AddVertex(Daughter.Vertex[V]);

	//create simplicies
	ivector1D simplexD(2, -1);
	simplexD[0]=iV;
	for(int i=0; i<counter; ++i){
		simplexD[1]=trueNeighs[i];
		boundaryCurve.AddSimplex(simplexD);
	}
} //next iV

boundaryCurve.RemoveTrueDoubleSimplex();
boundaryCurve.ResizeVertex();
boundaryCurve.ResizeSimplex();
boundaryCurve.BuildAdjacency();


//plot boundaryCurve in vtu
	std::string codex = "ascii";
	if(flag){codex="appended";}
	VTK_SM_CURVE handle_vtk_output(boundaryCurve, dir, name, codex);
	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	handle_vtk_output.Write();

return;
}//end method


//##############################################################################################
// utility function for output in VTU - Paraview format

void SupportMesh::plotVTU(std::string dir, std::string name, bool flag, dvector2D * vertices)
{
	dvecarr3E * vertices2;
	std::string codex = "ascii";
	if(flag){codex="appended";}
	VTK_SHAPE handle_vtk_output(&Daughter, dir, name, codex);
	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	if(vertices != NULL){
	  vertices2->resize(vertices->size(), darray3E{0,0,0});
	  for(int i=0; i<vertices->size(); ++i){
	  (*vertices2)[i] = conArray<double,3>((*vertices)[i]);
	  }
	   handle_vtk_output.linkExternalVertexList(*vertices2);
	  
	}
	handle_vtk_output.Write();

	return;
};

void SupportMesh::plotScalarVTU(std::string dir, std::string name, bool flag, int counter, dvector1D& field, dvector2D * vertices)
{
	dvecarr3E * vertices2;
	std::string codex = "ascii";
	if(flag){codex="appended";}
	VTK_SHAPE handle_vtk_output(&Daughter, dir, name, codex);

	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");

	if(vertices != NULL){
	   vertices2->resize(vertices->size(), darray3E{0,0,0});
	  for(int i=0; i<vertices->size(); ++i){
	  (*vertices2)[i] = conArray<double,3>((*vertices)[i]);
	  }

	  handle_vtk_output.linkExternalVertexList(*vertices2);
	  
	}

	if(counter>=0){handle_vtk_output.SetCounter(counter);}

	std::string loc_;
	if(field.size() == Daughter.nVertex){loc_="Point";}
	if(field.size() == Daughter.nSimplex){loc_="Cell";}

	if(loc_.empty()){std::cout<<"scalar field not suitable to be written on mesh, nor by points nor by cells"<<endl; return;}

	handle_vtk_output.AddData("scalarField",1, "Float64", loc_, codex);
	handle_vtk_output.linkScalarField(field);

	handle_vtk_output.Write();

	return;
};

void SupportMesh::plotVectorVTU(std::string dir, std::string name, bool flag, int counter, dvector2D & field, dvector2D * vertices)
{
	dvecarr3E * vertices2;
	dvecarr3E field2;
	std::string codex = "ascii";
	if(flag){codex="appended";}
	VTK_SHAPE handle_vtk_output(&Daughter, dir, name, codex);
	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	if(vertices != NULL){  vertices2->resize(vertices->size(), darray3E{0,0,0});
	  for(int i=0; i<vertices->size(); ++i){
	  (*vertices2)[i] = conArray<double,3>((*vertices)[i]);
	  }

	  handle_vtk_output.linkExternalVertexList(*vertices2);
	  }

	if(counter>=0){handle_vtk_output.SetCounter(counter);}

	std::string loc_;
	if(field.size() == Daughter.nVertex){loc_="Point";}
	if(field.size() == Daughter.nSimplex){loc_="Cell";}

	if(loc_.empty()){std::cout<<"scalar field not suitable to be written on mesh, nor by points nor by cells"<<endl; return;}

	handle_vtk_output.AddData("vectorField",3, "Float64", loc_, codex);
	
	field2.resize(field.size(), darray3E{0,0,0});
	  for(int i=0; i<field.size(); ++i){
	  field2[i] = conArray<double,3>(field[i]);}
	
	handle_vtk_output.linkVectorField(field2);

	handle_vtk_output.Write();

	return;
};



//###################################################################################################
// utility function for writing STL

void SupportMesh::plotSTL(string fileinput,
		std::vector<std::vector<double> > & vertices, bool flag) {
	// =================================================================================== //
	//                                                                                     //
	// Export tassellation in a .stl file (triangulation only)                             //
	// given an ensemble vertices[nvertices][3] where nvertices==nVertex                   //
	// The original Connectivity simplex/vertex of tasselation is used                     //
	// =================================================================================== //
	// EXPORT MESH IN STL FILE                                                             //
	// =================================================================================== //
	STL_obj STL_solid(trim(fileinput), flag);

	//convert vertices in dvecarr3E
	int size=vertices.size();
	dvecarr3E dumvec(vertices.size());

	for(int i=0; i<size; ++i){
		dumvec[i] = conArray<double,3>(vertices[i]);
	}

	STL_solid.save("", Daughter.nVertex, Daughter.nSimplex, dumvec, Daughter.Normal,
			Daughter.Simplex);

	return;
};

void SupportMesh::plotDGF(string fileinput,  std::vector<std::vector< double> > & vertices)
{
	// =================================================================================== //
	// Export tassellation in a .dgf dune format(triangulation only)                       //
	// given an ensemble vertices[nvertices][3] where nvertices==nVertex                   //
	// The original Connectivity simplex/vertex of tasselation is used                     //
	// =================================================================================== //
	// EXPORT MESH IN STL FILE                                                             //
	// =================================================================================== //

	int nvertices = Daughter.nVertex;

	DGF_obj DGF(trim(fileinput));

	DGF.save(nvertices, Daughter.nSimplex, vertices, Daughter.Simplex);

	return;
}

bool SupportMesh::isLevelSet(){return(levelSetCalc);}

//Class ParaSurfMesh

ParaSurfMesh::ParaSurfMesh(): SupportMesh()
{
	typeSegmentation = -1;
};
ParaSurfMesh::~ParaSurfMesh()
{
	cleanMap();
};

ParaSurfMesh::ParaSurfMesh(const ParaSurfMesh & other){


	name = other.name;

	Daughter.nVertex  = other.Daughter.nVertex;
    Daughter.nSimplex = other.Daughter.nSimplex;
    Daughter.ResizeVertex();
    Daughter.ResizeSimplex();
    for(int i=0; i<Daughter.nVertex; ++i){
    	Daughter.Vertex[i] = other.Daughter.Vertex[i];
    }
    for(int i=0; i<Daughter.nSimplex; ++i){
        	Daughter.Simplex[i] = other.Daughter.Simplex[i];
    }

    SDFheat.resize(other.SDFheat.size());
    SDFheat = other.SDFheat;

    SDFTri.resize(other.SDFTri.size());
    SDFTri = other.SDFTri;

    {int size = other.SDFGrad.size();
     SDFGrad.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 SDFGrad[i] = other.SDFGrad[i];
     }
    }

    {int size = other.AdjacencyVV.size();
     AdjacencyVV.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVV[i].resize(other.AdjacencyVV[i].size());
    	 AdjacencyVV[i]=other.AdjacencyVV[i];
     }
    }

    {int size = other.AdjacencyVT.size();
     AdjacencyVT.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVT[i].resize(other.AdjacencyVT[i].size());
    	 AdjacencyVT[i]=other.AdjacencyVT[i];
     }
    }

    {int size = other.inverseConn.size();
     inverseConn.resize(size);
     for(int i=0; i<size; ++i){
    	 inverseConn[i].resize(other.inverseConn[i].size());
    	 inverseConn[i]=other.inverseConn[i];
     }
    }

    initialVertexFront.resize(other.initialVertexFront.size());
    initialVertexFront = other.initialVertexFront;

    boundaryFront.resize(other.boundaryFront.size());
    boundaryFront = other.boundaryFront;

    currentSelection.resize(other.currentSelection.size());
    currentSelection = other.currentSelection;

    mapMotherV.resize(other.mapMotherV.size());
    mapMotherV = other.mapMotherV;

    simArea.resize(other.simArea.size());
    simArea  = other.simArea ;

    VoronoiDiag.resize(other.VoronoiDiag.size());
    VoronoiDiag = other.VoronoiDiag;

    {int size = other.cotangentList.size();
    cotangentList.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 cotangentList[i] = other.cotangentList[i];
     }
    }



    levelset = other.levelset;
    heatTime = other.heatTime;

    {int size = other.xyMap.size();
    	xyMap.resize(size);
        for(int i=0; i<size; ++i){
        	xyMap[i].resize(other.xyMap[i].size());
        	xyMap[i]=other.xyMap[i];
        }
       }

    boundSegmentedMap.resize(other.boundSegmentedMap.size());
    boundSegmentedMap  = other.boundSegmentedMap ;

    boundCurve.nVertex  = other.boundCurve.nVertex;
    boundCurve.nSimplex = other.boundCurve.nSimplex;
    boundCurve.ResizeVertex();
    boundCurve.ResizeSimplex(2);
    for(int i=0; i<boundCurve.nVertex; ++i){
    	boundCurve.Vertex[i] = other.boundCurve.Vertex[i];
    }
    for(int i=0; i<boundCurve.nSimplex; ++i){
    	boundCurve.Simplex[i] = other.boundCurve.Simplex[i];
    }

    typeSegmentation = other.typeSegmentation;
    seed.resize(other.seed.size(),0);
    list_geo.resize(other.list_geo.size(),"");
    seed = other.seed;
    list_geo = other.list_geo;

}

ParaSurfMesh& ParaSurfMesh::operator=(const ParaSurfMesh  & other){


	name = other.name;

	Daughter.nVertex  = other.Daughter.nVertex;
    Daughter.nSimplex = other.Daughter.nSimplex;
    Daughter.ResizeVertex();
    Daughter.ResizeSimplex();
    for(int i=0; i<Daughter.nVertex; ++i){
    	Daughter.Vertex[i] = other.Daughter.Vertex[i];
    }
    for(int i=0; i<Daughter.nSimplex; ++i){
        	Daughter.Simplex[i] = other.Daughter.Simplex[i];
    }

    SDFheat.resize(other.SDFheat.size());
    SDFheat = other.SDFheat;

    SDFTri.resize(other.SDFTri.size());
    SDFTri = other.SDFTri;

    {int size = other.SDFGrad.size();
     SDFGrad.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 SDFGrad[i] = other.SDFGrad[i];
     }
    }

    {int size = other.AdjacencyVV.size();
     AdjacencyVV.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVV[i].resize(other.AdjacencyVV[i].size());
    	 AdjacencyVV[i]=other.AdjacencyVV[i];
     }
    }

    {int size = other.AdjacencyVT.size();
     AdjacencyVT.resize(size);
     for(int i=0; i<size; ++i){
    	 AdjacencyVT[i].resize(other.AdjacencyVT[i].size());
    	 AdjacencyVT[i]=other.AdjacencyVT[i];
     }
    }

    {int size = other.inverseConn.size();
     inverseConn.resize(size);
     for(int i=0; i<size; ++i){
    	 inverseConn[i].resize(other.inverseConn[i].size());
    	 inverseConn[i]=other.inverseConn[i];
     }
    }

    initialVertexFront.resize(other.initialVertexFront.size());
    initialVertexFront = other.initialVertexFront;

    boundaryFront.resize(other.boundaryFront.size());
    boundaryFront = other.boundaryFront;

    currentSelection.resize(other.currentSelection.size());
    currentSelection = other.currentSelection;

    mapMotherV.resize(other.mapMotherV.size());
    mapMotherV = other.mapMotherV;

    simArea.resize(other.simArea.size());
    simArea  = other.simArea ;

    VoronoiDiag.resize(other.VoronoiDiag.size());
    VoronoiDiag = other.VoronoiDiag;

    {int size = other.cotangentList.size();
    cotangentList.resize(size, dvector1D(3,0));
     for(int i=0; i<size; ++i){
    	 cotangentList[i] = other.cotangentList[i];
     }
    }



    levelset = other.levelset;
    heatTime = other.heatTime;

    {int size = other.xyMap.size();
    	xyMap.resize(size);
        for(int i=0; i<size; ++i){
        	xyMap[i].resize(other.xyMap[i].size());
        	xyMap[i]=other.xyMap[i];
        }
       }

    boundSegmentedMap.resize(other.boundSegmentedMap.size());
    boundSegmentedMap  = other.boundSegmentedMap ;

    boundCurve.nVertex  = other.boundCurve.nVertex;
    boundCurve.nSimplex = other.boundCurve.nSimplex;
    boundCurve.ResizeVertex();
    boundCurve.ResizeSimplex(2);
    for(int i=0; i<boundCurve.nVertex; ++i){
    	boundCurve.Vertex[i] = other.boundCurve.Vertex[i];
    }
    for(int i=0; i<boundCurve.nSimplex; ++i){
    	boundCurve.Simplex[i] = other.boundCurve.Simplex[i];
    }

    typeSegmentation = other.typeSegmentation;
    seed.resize(other.seed.size(),0);
    list_geo.resize(other.list_geo.size(),"");
    seed = other.seed;
    list_geo = other.list_geo;


    return(*this);
}
void	ParaSurfMesh::cleanMap()
{
	freeContainer(xyMap);
	freeContainer(boundSegmentedMap);
	freeContainer(Daughter.Edge);
	freeContainer(Daughter.ENormal);
	freeContainer(Daughter.Simplex2Edge);
	freeContainer(Daughter.VNormal);
	cleanSDF();
};



void	ParaSurfMesh::evaluateBiMap()
{
	ivector1D deadList;
	if (boundaryFront.size() == 0 || AdjacencyVV.size() == 0 || AdjacencyVT.size()==0 )
	{
		std::cout<<"error not initialized support mesh for evaluation of. Please launch prepare Support first"<<endl;
	}


	xyMap.resize(Daughter.nVertex, dvector1D(3,0.0));

	//generate service structure of triangulation
	Daughter.GenerateVNormals();

	if(VoronoiDiag.size() == 0) {
	//compute Voronoi diagram on triangulation
	voronoiEF(VoronoiDiag);
	}

	double sumArea = 0.0;
	for (int k = 0; k<Daughter.nSimplex; k++)
	{
		sumArea += simArea[k];
	}//next k

	double time = 1e+18;//1000000000*sumArea;//double(Daughter.nSimplex);

	double alfaBC = 1.0;
	dvector2D LS(2);


	//here we choose between splitting techs
	bool checkSegment;
	dvector1D zeros(3,0.0);

	switch(typeSegmentation){


	case 0://segment your boundary
		checkSegment=segmentBoundary();
		if(!checkSegment) {std::cout<< "Boundary Decomposition Failed"<<std::endl;}

		//reorient segmentation according to a seed point
		 orientSegmentation();
		 break;

	case 1:
		checkSegment=segmentBoundaryExtGeo(list_geo);
		if(!checkSegment) {std::cout<< "Boundary Decomposition Failed w/ external goemetry files"<<std::endl;}
		 break;

	default:
		std::cout<<"WARNING! CAMILO has no info on method to segment your boundary. It will use an autosplitting method with"<<endl;
		std::cout<<"seed [0,0,0]."<<endl;
		setTypeSegmentation(zeros);

		checkSegment=segmentBoundary();
		if(!checkSegment) {std::cout<< "Boundary Decomposition Failed"<<std::endl;}

		//reorient segmentation according to a seed point
		 orientSegmentation();
		 break;
	}


	for(int btype=0; btype<2; ++btype){
		HeatSolveEFSparse(LS[btype], time, alfaBC, btype);
	}


	//pour it in the apposite member
	for(int j=0; j<Daughter.nVertex; ++j)
	{
		xyMap[j][0] = LS[0][j];
		xyMap[j][1] = LS[1][j];
		xyMap[j][2] = 0.0;
	}

	levelSetCalc=true;

};

bool 	ParaSurfMesh::segmentBoundary()
{
	bool result = true;
	if(boundaryFront.size() == 0){result=false; return (result);}

	createCurves(boundaryFront);

/*	std::string codex = "ascii";
	std::string folder="Output/Result";
	std::string outfile="originalFront";
   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, boundaryFront.size());
   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
   	dvector2D dummyVert(boundaryFront.size(), dvector1D(3,0));

   	for(int k=0; k<boundaryFront.size(); ++k){
   		dummyVert[k] = boundCurve.Vertex[k];
   	}

   	handle_vtk_output.linkData(dummyVert);
   	handle_vtk_output.Write();
exit(1);
*/
	dvector1D angles;
	ivector1D orderedCurve, orderedSegment;
	ivector1D mapV = regularizeBoundary(angles, &orderedCurve,  &orderedSegment) ;

	std::cout<<angles<<endl;

	//Now segment it.
	int sizeB = boundaryFront.size();
	boundSegmentedMap.resize(sizeB,0);

/*		std::string codex = "ascii";
		std::string folder="Output/Result";
		std::string outfile="boundaryCloud";
	   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, mapV.size());
	   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	   	dvector2D dummyVert(mapV.size(), dvector1D(3,0));

	   	for(int k=0; k<mapV.size(); ++k){
	   		dummyVert[k] = boundCurve.Vertex[mapV[k]];
	   	}

	   	handle_vtk_output.linkData(dummyVert);
	   	handle_vtk_output.Write();
	exit(1);
*/
	   	ivector1D extrema = find4points(mapV, angles, orderedCurve);

/*	std::string codex = "ascii";
		std::string folder="Output/Result";
		std::string outfile="boundaryCloud";
	   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, mapV.size());
	   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	   	dvector2D dummyVert(4, dvector1D(3,0));

	   	for(int k=0; k<4; ++k){
	   		dummyVert[k] = boundCurve.Vertex[orderedCurve[extrema[k]]];
	   	}


	   	handle_vtk_output.linkData(dummyVert);
	   	handle_vtk_output.Write();

	   	exit(1);
*/
	   	for(int ll=0; ll<3; ++ll){
	for(int k=extrema[ll]+1; k<=extrema[ll+1]; ++k){
		boundSegmentedMap[orderedSegment[k]]=ll+1;
	}
}

/*	   	ivector1D dummyV = extractDeadBoundary(0);
    	std::string codex = "ascii";
		std::string folder="Output/Result";
		std::string outfile="boundaryCloud";
	   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, dummyV.size());
	   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	   	dvector2D dummyVert(dummyV.size(), dvector1D(3,0));

	   	for(int k=0; k<dummyV.size(); ++k){
	   		dummyVert[k] = Daughter.Vertex[dummyV[k]];
	   	}


	   	handle_vtk_output.linkData(dummyVert);
	   	handle_vtk_output.Write();

	   	exit(1);
*/

	return(result);
};

void ParaSurfMesh::createCurves(ivector1D & map)
{

	if(AdjacencyVV.size() == 0 || AdjacencyVT.size() == 0){
		std::cout<<"TriangularMesh Support not Defined. Please defined it first!"<<std::endl;
		exit(1);
	}

	// Local variables
	int mapT = map.size();
	for (int iV = 0; iV < mapT; ++iV) {
		int V = map[iV];
		int n = AdjacencyVV[V].size();

		ivector1D trueNeighs(n,-1);
		ivector1D dummy_vec(n,-1);
		int counter=0;
		for(int i=0; i<n; ++i){
			int pos = posVectorFind(map, AdjacencyVV[V][i]);
			if(pos != -1){
				trueNeighs[counter]=pos;
				++counter;
			}

		}

		trueNeighs.resize(counter);

		//refine trueNeighs search
		if (counter > 2){

			int countNew=0;
			dummy_vec.resize(counter);
			int nT=AdjacencyVT[V].size();

			for(int iK=0; iK<counter;++iK){
				for(int iT=0; iT<nT; ++iT){

					int pos = posVectorFind(Daughter.Simplex[AdjacencyVT[V][iT]], map[trueNeighs[iK]]);

					if(pos !=-1){
						int target = AdjacencyVT[V][iT];
						int locEdge = Daughter.edge(target,V,map[trueNeighs[iK]]);
						if(Daughter.Adjacency[target][locEdge][0] == -1){
							dummy_vec[countNew] = trueNeighs[iK];
							++countNew;
						}
					}

				}
			}
			dummy_vec.resize(countNew);
			trueNeighs.resize(countNew);
			trueNeighs = dummy_vec;
			counter = countNew;
		}

		//adding vertex
		boundCurve.AddVertex(Daughter.Vertex[V]);

		//create simplicies
		ivector1D simplexD(2, -1);
		simplexD[0]=iV;
		for(int i=0; i<counter; ++i){
			simplexD[1]=trueNeighs[i];
			boundCurve.AddSimplex(simplexD);
		}
	} //next iV

	boundCurve.RemoveTrueDoubleSimplex();
	boundCurve.ResizeVertex();
	boundCurve.ResizeSimplex();
	boundCurve.BuildAdjacency();

	//Adjust their numbering
	// first check connectivity & adjacency of the seed
	curveSeedOrientation(0);
	//adjust all the others accordingly;
	CG_PLCurve::AdjustOrder(boundCurve.Simplex, boundCurve.Adjacency, 0);
	boundCurve.GenerateNormals();

//	boundCurve.Stats(cout);
	return;
};

void  ParaSurfMesh::heatMatrixSparse(double * Tdmat, double * Lpmat, int * jA,
									 int * iA, double & time, double & alphaBC, int & btype)
{//instantiate the Heat matrix with symmetry boundary condition, whenever a Dirichlet is not enforced by a flag true. iA, jA of CSR Lpmat are indexed in fortran convention (from 1 to nDimension and NOT from 0 to nDimension
	// CHANGED: the flag no longer exists: a double, i.e. alphaBC, has been added in order to introduce a Robin boundary condition (weighted combination of Dirichlet and Neumann).

	ivector1D deadDown = extractDeadBoundary(btype);
	ivector1D deadUp   = extractDeadBoundary(btype+2);
	int nDim = Daughter.nVertex;
	double alpha;

	// check alpha values
	if(alphaBC<0){
		alpha=0.0;	// a<0.0 -> Dirichlet
	}
	else if(alphaBC>1){
		alpha=1.0;	// a>1.0 -> Neumann
	}
	else {
		alpha=alphaBC;	// Robin (!*)
	}


	for (int i=0; i<nDim; ++i){


		ivector1D::iterator it_n = find(boundaryFront.begin(), boundaryFront.end(), i);

		if(it_n != boundaryFront.end()){ // internal nodes

			ivector1D::iterator it_down = find(deadDown.begin(), deadDown.end(), i);
			ivector1D::iterator it_up   = find(deadUp.begin(), deadUp.end(), i);
			int jtarget = findCSRPosition(i,i,jA,iA);

			if(it_down != deadDown.end() ||it_up != deadUp.end() ) {
				Tdmat[jtarget] = 1.0;
			} // vinculated nodes -> Dirichlet boundary conditions

			else {// free nodes  -> user-specified boundary conditions (depending on alpha values)
				for(int k=iA[i]; k<iA[i+1]; k++)Tdmat[k] = Lpmat[k]*alpha;
				ivector2D freeEd = extractFreeEdges(i);

				for(int k1=0; k1<2; k1++)
				{
					dvector1D jacobian = jacobianGradient(freeEd[k1][0], freeEd[k1][1]);

					for (int k2=0; k2<3; k2++)
					{
						int J = Daughter.Simplex[freeEd[k1][0]][k2];
						int jtarget = findCSRPosition(i , J, jA, iA);
						Tdmat[jtarget] += -1.0*jacobian[k2]*alpha;
					}//next k2
				}//next k1
				Tdmat[jtarget]+=(1-alpha)*1.0;
			}//end else (vinculated/free nodes)
		}
		else { // nodes belonging to boundary front

			for(int j=iA[i]; j<iA[i+1]; j++) {Tdmat[j] = time*Lpmat[j];} //selected row of ith-node

			int jtarget = findCSRPosition (i , i, jA, iA);
			Tdmat [jtarget] += VoronoiDiag[i];

		}//end else (internal/boundary front nodes)
	}//next i



}//end of heatMatrix

void ParaSurfMesh::HeatSolveEFSparse( dvector1D & LS, double & time, double & alphaBC, int & btype)
{// solving the heat equation to recover a distance path function. Finite elements version
	// three step are provided.
	//	1) solving the implicit heat equation for a certain time, starting from an initial condition of 1 on the dead nodes
	//	2) Recover gradients of the solution on the step 1 and evaluate divergence
	//	3) solving the poisson equation for distance function, with divergence in the step 2 as source term
	//
	//final solution after the step 3 is stored in SDF. SPARSE version


	SuperMatrix A, L, U, B;

	int                 *perm_r; /* row permutations from partial pivoting */
	int                 *perm_c; /* column permutation vector */

	int                 info, permc_spec;

	superlu_options_t   options;
	SuperLUStat_t       stat;


	double *LapMat, *LapMat2;
	double *TDmat, *RHS;
	int *Jmat, *Imat;
	int nLapDim;
	int nDim = Daughter.nVertex;

	dvector1D zeros(nDim,0.0);
	std::cout<< "Characteristic dimension of the Heat Linear System  "<<nDim<<endl;

	ivector1D deadDown = extractDeadBoundary(btype);
	ivector1D deadUp = extractDeadBoundary(btype+2);

//	std::cout<<deadDown<<endl;
//	std::cout<<deadUp<<endl;

	int downSize = deadDown.size();
	int upSize = deadUp.size();

	if(deadDown.size() !=0 && deadUp.size() != 0) {
		LapMat = bulkMassMatrixSparse(nLapDim, Jmat, Imat);

		RHS   = new double[nDim]();

		//double A_lenght = lenCurve(deadDown, Daughter);
		//double B_lenght = lenCurve(deadUp, Daughter);

		//double counterBC = A_lenght/B_lenght;
		//std::cout<<A_lenght<<'\t'<<B_lenght<<'\t'<<counterBC<<endl;

		for (int i=0; i<downSize; i++) {RHS[deadDown[i]] = 0.0;}
		for (int i=0; i<upSize; i++) {RHS[deadUp[i]] = 1.0;}

/*		LapMat2 =new double[nLapDim];
		for(int k=0; k<nLapDim; ++k){
			LapMat2[k] = LapMat[k];
		}
*/
	};


		// prepare timedependent Matrix TDmat
		//		 ivector1D deadL = extractDeadVList();
		LS.resize(nDim, 0.0);
		dvector1D solution(nDim, 0.0);

		TDmat = new double[nLapDim]();
//		double alphaBC ---> (1-a)*Dirichlet + a*Neumann
		heatMatrixSparse(TDmat, LapMat, Jmat, Imat, time,  alphaBC, btype);
		//ht TDmat is matrix in sparse format

		/* Create matrix A in the format expected by SuperLU. */
		dCreate_CompRow_Matrix(&A, nDim, nDim, nLapDim, TDmat, Jmat, Imat, SLU_NR, SLU_D, SLU_GE);

		/* Create right-hand side matrix B. */
		dCreate_Dense_Matrix(&B, nDim, 1, RHS, nDim, SLU_DN, SLU_D, SLU_GE);

		if ( !(perm_r = intMalloc(nDim)) ) ABORT("Malloc fails for perm_r[].");
		if ( !(perm_c = intMalloc(nDim)) ) ABORT("Malloc fails for perm_c[].");

		/* Set the default input options. */
		set_default_options(&options);
		//options.ColPerm = NATURAL;
		options.SymmetricMode=YES;
		/* Initialize the statistics variables. */
		StatInit(&stat);

		/* Solve the linear system. */
		dgssv(&options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);
		std::cout << "exit condition of first linear system " << info << std::endl ;


		{ int i;

		for( i=0; i<nDim; ++i){
			solution[i] = RHS[i] ;
		}
		};

/*		Destroy_SuperMatrix_Store(&A);
		Destroy_SuperMatrix_Store(&B);

		Destroy_SuperNode_Matrix(&L);
		Destroy_CompCol_Matrix(&U);


		//Second step -> gradient and divergence of the solution
		dvector2D GradientNorm = normGradOnTriangulation(solution);
		dvector1D Divergence   = quadratureDivergence(GradientNorm);


		//Third Step -> Poisson relaxing Step /

		//first bound
		// Imposing Dirichlet boundary conditions whenever the Dirichlet flag is true //
			for (int i=0; i<nDim; i++) RHS[i] = -1.0*Divergence[i];
			for (int i=0; i<downSize; i++) {
				RHS[deadDown[i]] = 0.0;
				int jTarg  = findCSRPosition(deadDown[i], deadDown[i], Jmat, Imat);

				for(int j=Imat[deadDown[i]]; j<Imat[deadDown[i]+1]; j++)
				{
					LapMat[j]  = 0.0;
				}
				LapMat[jTarg] = 1.0;
			}

		// Create matrix A in the format expected by SuperLU. //
		dCreate_CompRow_Matrix(&A, nDim, nDim, nLapDim, LapMat, Jmat, Imat, SLU_NR, SLU_D, SLU_GE);

		// Create right-hand side matrix B. //
		dCreate_Dense_Matrix(&B, nDim, 1, RHS, nDim, SLU_DN, SLU_D, SLU_GE);

		// Set the default input options. //
		set_default_options(&options);
		options.ColPerm = NATURAL;

		// Initialize the statistics variables. //
		StatInit(&stat);

		// Solve the linear system. //
		dgssv(&options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);
		std::cout << "exit condition of second linear system " << info << std::endl ;

		{ int i;
		for( i=0; i<nDim; ++i){
			solution[i] = RHS[i] ;
		}
		};

		double refValue = 1e+18;
		{
		dvector1D PhiMin;
		ivector1D mapVert = findRefValueOnBoundary(solution, deadUp, PhiMin, true);

		for(int kP=0; kP<PhiMin.size(); kP++)
		refValue = fmin(refValue, PhiMin[kP]);
		}

		Destroy_SuperMatrix_Store(&A);
		Destroy_SuperMatrix_Store(&B);

		Destroy_SuperNode_Matrix(&L);
		Destroy_CompCol_Matrix(&U);

		//second bound
		// Imposing Dirichlet boundary conditions whenever the Dirichlet flag is true //
			for (int i=0; i<nDim; i++) RHS[i] = -1.0*Divergence[i];
			for (int i=0; i<upSize; i++) {
				RHS[deadUp[i]] = refValue;
				int jTarg  = findCSRPosition(deadUp[i], deadUp[i], Jmat, Imat);

				for(int j=Imat[deadUp[i]]; j<Imat[deadUp[i]+1]; j++)
				{
					LapMat2[j]  = 0.0;
				}
				LapMat2[jTarg] = 1.0;
			}

		// Create matrix A in the format expected by SuperLU. //
		dCreate_CompRow_Matrix(&A, nDim, nDim, nLapDim, LapMat2, Jmat, Imat, SLU_NR, SLU_D, SLU_GE);

		// Create right-hand side matrix B. //
		dCreate_Dense_Matrix(&B, nDim, 1, RHS, nDim, SLU_DN, SLU_D, SLU_GE);

		// Set the default input options. //
		set_default_options(&options);
		options.ColPerm = NATURAL;

		// Initialize the statistics variables. //
		StatInit(&stat);

		// Solve the linear system. //
		dgssv(&options, &A, perm_c, perm_r, &L, &U, &B, &stat, &info);
		std::cout << "exit condition of second linear system " << info << std::endl ;

		{ int i;

		for( i=0; i<nDim; ++i){
			solution[i] = 0.5*(solution[i] + RHS[i]) ; //averaging the two solution

		}
		};
*/
		// De-allocate storage //
		SUPERLU_FREE (perm_r);
		SUPERLU_FREE (perm_c);


		Destroy_SuperMatrix_Store(&A);
		Destroy_SuperMatrix_Store(&B);

		Destroy_SuperNode_Matrix(&L);
		Destroy_CompCol_Matrix(&U);


		delete [] LapMat; LapMat = NULL ;
//		delete [] LapMat2; LapMat2=NULL;
		delete [] TDmat; TDmat = NULL ;
		delete [] Imat; Imat = NULL ;
		delete [] Jmat; Jmat = NULL ;
		delete [] RHS; RHS = NULL ;


		//save solution in LS
		for (int i=0; i<nDim; i++) {LS[i] = solution[i];}

/*
		{
			dvector1D PhiMin;
			ivector1D mapVert = findRefValueOnBoundary(solution, deadUp, PhiMin, true);

			for(int kP=0; kP<PhiMin.size(); kP++)
				refValue = fmin(refValue, PhiMin[kP]);
			std::cout<<"Found reference value for bivariant map: "<<refValue<<endl;
			}
		for (int i=0; i<nDim; i++) {LS[i] = LS[i]/ refValue;}

*/

return;
}//end of HeatSolveEF

ivector1D ParaSurfMesh::extractDeadBoundary(int ktype)
{
	ivector1D result;
	if(boundCurve.Vertex.size() == 0 || boundSegmentedMap.size()== 0 || boundaryFront.size()==0){return (result);}

	int Bsize = boundCurve.nSimplex;
	std::map<int,int> mapV;

	for (int i=0; i<Bsize; ++i)
	{
		if(boundSegmentedMap[i] == ktype)
		{
			mapV[boundaryFront[boundCurve.Simplex[i][0]]]= boundaryFront[boundCurve.Simplex[i][0]];
			mapV[boundaryFront[boundCurve.Simplex[i][1]]]= boundaryFront[boundCurve.Simplex[i][1]];
		}
	}//next i

	result.resize(mapV.size(),-1);
	int counter = 0;
	for(std::map<int,int>::iterator itF=mapV.begin(); itF !=mapV.end(); ++itF){
		result[counter]  = (*itF).second;
		++counter;
	}

	return(result);
};//end of extractDeadBoundary

double ParaSurfMesh::editMaxSharpness(Class_SurfTri & curve){

	double result;

	std::map<double,double> mapSharp;

	if(curve.Normal.size()==0){curve.GenerateNormals();}
	if(curve.Adjacency.size()==0){curve.BuildAdjacency();}

	dvector1D normal0(3,0), normal1(3,0);

	for(int S=0; S<curve.nSimplex; ++S){

		normal0 = conVect(curve.Normal[S]);
		int m = curve.Simplex[S].size();

		for (int i = 0; i < m; i++) {
		        if (curve.Adjacency[S][i][0] >= 0) {
		            if (curve.Adjacency[S][i].size() == 1) {
		                int T = curve.Adjacency[S][i][0];
		                normal1= conVect(curve.Normal[T]);
		                double val = ((int)(norm_2(normal0-normal1) *10))/10;
		                mapSharp[val] = val;
		            }
		        }
		}
	}
		//check mapShap size
		std::map<double,double>::iterator itF;

		if(mapSharp.size() >=4){
			itF = mapSharp.end();
			for(int k=0; k<4; k++){itF--;}
		}
		else {
		    itF = mapSharp.end();
		}

		result= (*itF).second;

	return(result);
}

ivector1D ParaSurfMesh::regularizeBoundary(dvector1D & angles, ivector1D * orderedCurve, ivector1D * orderedSegment )
{
	ivector1D result;
	dvector2D vertices;
	int result_size;
	if(boundCurve.nVertex == 0){return(result);}
	if(!CG_PLCurve::IsClosed(boundCurve.Adjacency) ) {
		std::cout<<"the curve selected is not closed "<<endl;
		return(result);}


	angles.resize(boundCurve.nVertex, -1.0);
	if(orderedCurve != NULL)(*orderedCurve).resize(boundCurve.nVertex, -1.0);
	if(orderedSegment != NULL)(*orderedSegment).resize(boundCurve.nVertex, -1.0);
	//initializing your ordered loop of boundary segments

	//Evaluate a representative normal of the surface from which the boundary is extracted
	// i.e. average the Daughter Vertex Normals.
	dvector1D SurfaceNormal(3,0.0);
	for(int k=0; k<Daughter.nVertex; ++k){
		SurfaceNormal = SurfaceNormal + conVect(Daughter.VNormal[k])/((double) Daughter.nVertex);
	}

	result = sortCurve(boundCurve, orderedSegment);
	if(orderedCurve != NULL) {(*orderedCurve) = result;}

	int counter = result.size();

	do{
		//calculate angles
		for(int i=0; i<counter; ++i){

			int iV = result[i];
			int iL = result[(i-1+counter)%counter];
			int iR = result[(i+1)%counter];

			dvector1D n1(3,0.0), n2(3,0.0), wNorm(3), Normal(3,0);
			Normal = SurfaceNormal; //VertexNormals[boundaryFront[iV]];

			n1 = conVect(boundCurve.Vertex[iV] - boundCurve.Vertex[iL]);
			n2 = conVect(boundCurve.Vertex[iR] - boundCurve.Vertex[iV]);

			n1 = n1 - Dot_Product(n1,Normal)*Normal;
			n2 = n2 - Dot_Product(n2,Normal)*Normal;

			n1 = n1/norm_2(n1);
			n2 = n2/norm_2(n2);

			double proj = Dot_Product(n1,n2);
			wNorm = Cross_Product(n1,n2);
			if(abs(proj)>0.99) {wNorm = Normal; proj=1.0;} //VertexNormals[boundaryFront[iV]]; proj=1.0;}

			double sign = Dot_Product(wNorm,Normal);
			if(abs(sign)< 0.01){sign=1.0;}
			else		 {sign = sign/abs(sign);}
			angles[i] = sign * acos(proj);
		}
		result_size = counter;
		counter = 0;
		//decimate results vector when angles value is negative
		for(int k=0; k<result_size; ++k){
			if(angles[k] >= 0){
				result[counter]=result[k];
				angles[counter]=angles[k];
				++counter;
			}
		}
		result.resize(counter);
		angles.resize(counter);

	}while(result_size != counter);

	return(result);
}

void ParaSurfMesh::curveSeedOrientation(int seed_)
{
	// check if your seed is available;

	if(boundCurve.nSimplex == 0 || seed_<0 ||seed_>= boundCurve.nSimplex){
		std::cout<<"seed not found in your curve.Exiting"<<endl;exit(1);
	}

	int V1, V2, targetS=-1;

	V1 = boundaryFront[boundCurve.Simplex[seed_][0]];
	V2 = boundaryFront[boundCurve.Simplex[seed_][1]];

	int v2_size = inverseConn[V2].size();
	int k=0;
	while(k<v2_size && targetS==-1){
		targetS = posVectorFind(inverseConn[V1], inverseConn[V2][k]);
		++k;
	}

	if(targetS == -1){std::cout<<"Not suitable simplicial mesh found for your boundary.Exiting"<<std::endl; exit(1);}

	int checkV1 = posVectorFind(Daughter.Simplex[targetS], V1);
	int checkV2 = (checkV1+1)%Daughter.Simplex[targetS].size();
	if(V2 != Daughter.Simplex[targetS][checkV2] ){

		// reverse seed ordering.

		int conn_temp = boundCurve.Simplex[seed_][0];
		int adj_temp  = boundCurve.Adjacency[seed_][0][0];

		boundCurve.Simplex[seed_][0] = boundCurve.Simplex[seed_][1] ;
		boundCurve.Adjacency[seed_][0][0] = boundCurve.Adjacency[seed_][1][0];

		boundCurve.Simplex[seed_][1] = conn_temp;
		boundCurve.Adjacency[seed_][1][0] = adj_temp;

	}
	return;
}//end method

ivector1D ParaSurfMesh::find4points(ivector1D & map, dvector1D & angles, ivector1D originalMap){

	ivector1D result;
	int size = angles.size();
	bvector1D gradientAngles(size, true);

//	std::cout<<angles<<endl;
	for (int i=0; i<size; ++i){

		int iL = (size+i-1)%size;
		if((angles[i] - angles[iL])< 0.0){gradientAngles[i] = false;}
	}

	ivector1D candidates;
	ivector1D realCand;
	for (int i=0; i<size; ++i){

		int iR = (i+1)%size;
		if(gradientAngles[i] && !gradientAngles[iR]){
			candidates.push_back(i);
		}
	}
	std::cout<<candidates<<endl;

	if(candidates.size() >3){

		std::map<double, int> mapCand;
		for (int i=0; i<candidates.size(); ++i){
			mapCand[angles[candidates[i]]] = candidates[i];
			}

		std::map<double,int>::iterator itFind = mapCand.end();
		int counter = 0;
		while(counter<4 && itFind != mapCand.begin()){
			--itFind;
			realCand.push_back((*itFind).second);
			++counter;
		}

		//finalcheck;
		for(int k=0; k<candidates.size(); ++k){
			int check=posVectorFind(realCand, candidates[k]);
			if(check !=-1){
				result.push_back(posVectorFind(originalMap, map[candidates[k]]));
			}
		}

	}


	return(result);
}

double ParaSurfMesh::lenCurve(ivector1D & map, Class_SurfTri & tri)
{

	double result = 0.0;

	int size = map.size();
	dvector1D seed(3,0); seed = conVect(tri.Vertex[map[0]]);

	for(int i=1; i<size; ++i){

		result += norm_2(conVect(tri.Vertex[map[i]]) - seed);
		seed = conVect(tri.Vertex[map[i]]);
	}

	return(result);
}

void ParaSurfMesh::orientSegmentation()
{
	// found nearest subcurve;
	double min_dist = 1.e+18;
	int ktype_cand = -1;

	for(int i=0; i<4; ++i){
		double curve_min_dist = 1.e+18;
		ivector1D deadV = extractDeadBoundary(i);
		int sizeDV = deadV.size();
		for(int j=0; j<sizeDV; ++j){

			curve_min_dist = fmin(curve_min_dist, norm_2(conVect(Daughter.Vertex[deadV[j]]) - seed));
		}

		if(curve_min_dist < min_dist){min_dist = curve_min_dist; ktype_cand = i;}
	}

	if(ktype_cand < 0){std::cout<<"A problem occurred in ParaSurfMesh::orientSegmentation. Exiting..."<<endl; exit(1); }

	//shifting all subcurve indices to match the ktype_cand to bo the new 0 curve
	int sizeM = boundSegmentedMap.size();
	for(int k=0; k<sizeM; ++k){
		boundSegmentedMap[k] = (boundSegmentedMap[k] + 4 - ktype_cand)%4;
	}

}

void ParaSurfMesh::setTypeSegmentation(dvector1D & seed_)
{
	seed.resize(seed_.size(),0);
	seed = seed_;
	typeSegmentation=0;
}

void ParaSurfMesh::setTypeSegmentation(svector1D & list_geo_)
{
	list_geo.resize(list_geo_.size(),"");
	list_geo = list_geo_;
	typeSegmentation=1;
}

Class_SurfTri ParaSurfMesh::extractBoundaryCurve(std::string & filename)
{
	Class_SurfTri curve;

	//first step read Geometry
	std::string tag;
	std::string key2 = ".";
	std::size_t cut2 =filename.rfind(key2);
	tag  = filename.substr(cut2);

	SHAPE geo;
	geo.init(filename);
	geo.cleaning();

	geo.Boundaries(curve);
	if(curve.Vertex.size()==0)
	{
		std::cout<<"WARNING! your geometry "<<filename<< " has no free boundaries"<<endl;

	}
	return(curve);
}

bool 	ParaSurfMesh::segmentBoundaryExtGeo(svector1D & list)
{
	bool result = true;

	if(boundaryFront.size() == 0 || list.size() != 4){result=false; return (result);}

	createCurves(boundaryFront);

/*
	std::string codex = "ascii";
	std::string folder="Output/Result";
	std::string outfile="originalFront";
   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, boundaryFront.size());
   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
   	dvector2D dummyVert(boundaryFront.size(), dvector1D(3,0));

   	for(int k=0; k<boundaryFront.size(); ++k){
   		dummyVert[k] = boundCurve.Vertex[k];
   	}
	handle_vtk_output.linkData(dummyVert);
   	handle_vtk_output.Write();

*/
	//sort in clockwise direction your curve
	ivector1D orderedSegment(boundCurve.nSimplex);
	ivector1D orderedCurve = sortCurve(boundCurve , &orderedSegment) ;

	//Now ready to segment it.
	int sizeB = boundaryFront.size();
	boundSegmentedMap.resize(sizeB,-1);

/*		std::string codex = "ascii";
		std::string folder="Output/Result";
		std::string outfile="boundaryCloud";
	   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, mapV.size());
	   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");

	   	dvector2D dummyVert(mapV.size(), dvector1D(3,0));

	   	for(int k=0; k<mapV.size(); ++k){
	   		dummyVert[k] = boundCurve.Vertex[mapV[k]];
	   	}

	   	handle_vtk_output.linkData(dummyVert);
	   	handle_vtk_output.Write();
	exit(1);
*/


	for(int ll=0; ll<4; ++ll){

		Class_SurfTri local_geo = extractBoundaryCurve(list[ll]);

		ivector1D match = compareCurves(boundCurve,local_geo);
		int size_match = match.size();

/*		std::string codex = "ascii";
		std::string folder="Output/Result";
		std::stringstream ss;
		ss<<"branch"<<ll;
		std::string outfile=ss.str();
	   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, size_match);
	   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	   	dvector2D dummyVert(size_match, dvector1D(3,0));

	   	for(int k=0; k<size_match; ++k){
	   		dummyVert[k] = boundCurve.Vertex[match[k]];
	   	}


	   	handle_vtk_output.linkData(dummyVert);
	   	handle_vtk_output.Write();

*/

		for(int k=0; k<size_match; ++k){

			int target=posVectorFind(orderedCurve, match[k]);
			boundSegmentedMap[orderedSegment[target]]=ll;
		}

/*		std::string codex = "ascii";
		std::string folder="Output/Result";

		std::stringstream ss;
		ss<<"frontOR "<<ll;
		std::string outfile = ss.str();
	   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, local_geo.nVertex);
	   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	   	handle_vtk_output.linkData(local_geo.Vertex);
	   	handle_vtk_output.Write();*/
	}


	   	for(int k=0; k<4; ++k){
  		ivector1D dummyV = extractDeadBoundary(k);
    	std::string codex = "ascii";
		std::string folder="Output/Result";
		std::string outfile;
		std::stringstream ss;
		ss<<"boundaryCloud_"<<k;
		outfile = ss.str();
	   	VTK_SM_CLOUD handle_vtk_output(folder, outfile, codex, dummyV.size());
	   	handle_vtk_output.SetGeomTypes("Float64", "Int32", "Int32", "Int32");
	   	dvector2D dummyVert(dummyV.size(), dvector1D(3,0));

	   	for(int k=0; k<dummyV.size(); ++k){
	   		dummyVert[k] = conVect(Daughter.Vertex[dummyV[k]]);
	   	}

	   	handle_vtk_output.linkData(dummyVert);
	   	handle_vtk_output.Write();
		}

//	   	exit(1);


	return(result);
};

ivector1D ParaSurfMesh::sortCurve(Class_SurfTri & boundC , ivector1D * orderedSegment)
{
	ivector1D result;

	if((boundC.nSimplex != boundC.nVertex) ||
			boundC.nSimplex == 0 ||
			boundC.nVertex == 0 )
	{
		return(result);
	}

	if(boundC.Adjacency.size() == 0) boundC.BuildAdjacency();

	result.resize(boundC.nVertex, -1);

	int tSim = 0;
	int counter=0;
	while(counter<boundC.nSimplex){
		result[counter]   = boundC.Simplex[tSim][1];

		if(orderedSegment != NULL)(*orderedSegment)[counter] = tSim;
		//update tSim
		tSim = boundC.Adjacency[tSim][1][0];
		++counter;
	}
	return (result);
}


ivector1D ParaSurfMesh::compareCurves(Class_SurfTri & mother, Class_SurfTri & daughter)
{
	ivector1D result(mother.nVertex);
	double tol = 1.0E-6;
	int counter=0;
	for(int i=0; i<mother.nVertex; ++i){
		int j = 0;
		bool check = false;
		while(j<daughter.nVertex && !check){

			double norm = norm_2(mother.Vertex[i] - daughter.Vertex[j]);
			if(norm <= tol){
				check=true;
				result[counter]=i;
				counter++;
			}
			++j;
		}
	}

	result.resize(counter);
	return(result);
}


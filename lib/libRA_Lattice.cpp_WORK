
#include "libRA_Lattice.hpp"


// Default constructor of OuterShell struct
OuterShell::OuterShell(){};

// Custom constructor of OuterShell struct
OuterShell::OuterShell(int n1, int n2, int n3)
{
	xdir.resize(n1);
	ydir.resize(n2);
	zdir.resize(n3);
};

//CopyConstructor of OuterShell struct
OuterShell::OuterShell(const OuterShell & other )
{
	xdir.resize(other.xdir.size());
	ydir.resize(other.ydir.size());
	zdir.resize(other.zdir.size());

	xdir = other.xdir;
	ydir = other.ydir;
	zdir = other.zdir;
};

//Assignment operator of OuterShell struct
OuterShell & OuterShell::operator=(const OuterShell & other )
{
	xdir.resize(other.xdir.size());
	ydir.resize(other.ydir.size());
	zdir.resize(other.zdir.size());

	xdir = other.xdir;
	ydir = other.ydir;
	zdir = other.zdir;

	return (*this);
};

VTK_LATTICE::VTK_LATTICE():VTK_UnstructuredGrid<VTK_LATTICE>()
{
	points = NULL;
	connectivity=NULL;
};

VTK_LATTICE::VTK_LATTICE( std::string dir_, std::string name_, std::string cod_, int nC_, int nP_, int nConn_):
								VTK_UnstructuredGrid<VTK_LATTICE>(dir_, name_)

{

	SetCodex(cod_);
	SetDimensions(nC_, nP_, nConn_);
	points=NULL;
	connectivity=NULL;
};

VTK_LATTICE::~VTK_LATTICE()
{
	points=NULL;
	connectivity=NULL;
};

void VTK_LATTICE::linkData(dvector2D & pp, ivector2D & conn )
{
	points = &pp;
	connectivity = &conn;

	//check data connection to vtk instatiated info and repair it.

	if(pp.size() != nr_points || conn.size() != nr_cells){

	SetDimensions( conn.size(), pp.size(), 8*conn.size());
	}

};

void VTK_LATTICE::unlinkData()
{
	points=NULL;
	connectivity=NULL;
};

void VTK_LATTICE::Flush(  fstream &str, string codex_, string name  )
{
	int n;
	 if(points == NULL || connectivity == NULL ){std::cout<<"not linked Data Structure"<<endl; return;}

	  string indent("         ") ;

	    if( codex_ == "ascii"){

	      if( name == "Points" ){
	        for( n=0; n<nr_points; n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, 3, (*points)[n]);
	          str << endl ;
	        };
	      };

	      if( name == "connectivity" ){
	        for( n=0; n<connectivity->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, 8, (*connectivity)[n]) ;
	          str << endl ;
	        };
	      };

	      if( name == "types" ){
	        int type_(12) ;
	        for( n=0; n<connectivity->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, type_  ) ;
	          str << endl ;
	        };
	      };

	      if( name == "offsets" ){
	        int off_(0) ;
	        for( n=0; n<connectivity->size(); n++) {
	          off_ += NumberOfElements( 12 ) ;
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, off_  ) ;
	          str << endl ;
	        };
	      };

	    }

	    else{

		      if( name == "Points" ){
		        for( n=0; n<nr_points; n++) {
		          flush_binary( str, (*points)[n]);
		        };
		      };

		      if( name == "connectivity" ){
		        for( n=0; n<connectivity->size(); n++) {
		          flush_binary( str, (*connectivity)[n]) ;
		        };
		      };

		      if( name == "types" ){
		        int type_(12) ;
		        for( n=0; n<connectivity->size(); n++) {
		          flush_binary( str, type_  ) ;
		        };
		      };

		      if( name == "offsets" ){
		        int off_(0) ;
		        for( n=0; n<connectivity->size(); n++) {
		          off_ += NumberOfElements( 12 ) ;
		          flush_binary( str, off_  ) ;
		        };
		      };

	      }

	  return ;

};

VTK_CLOUD::VTK_CLOUD():VTK_UnstructuredGrid<VTK_CLOUD>()
{
	points = NULL;
};

VTK_CLOUD::VTK_CLOUD( std::string dir_, std::string name_, std::string cod_, int nP_):
								VTK_UnstructuredGrid<VTK_CLOUD>(dir_, name_)

{
	SetCodex(cod_);
	SetDimensions(nP_, nP_, nP_);
	points=NULL;
};

VTK_CLOUD::~VTK_CLOUD()
{
	points=NULL;
};

void VTK_CLOUD::linkData(dvector2D & pp)
{
	points = &pp;

	//check data connection to vtk instatiated info and repair it.

	if(pp.size() != nr_points){

	SetDimensions( pp.size(), pp.size(), pp.size());
	}

};

void VTK_CLOUD::unlinkData()
{
	points=NULL;
};

void VTK_CLOUD::Flush(  fstream &str, string codex_, string name  )
{
	int n;
	 if(points == NULL ){std::cout<<"not linked Data Structure"<<endl; return;}

	  string indent("         ") ;

	    if( codex_ == "ascii"){

	      if( name == "Points" ){
	        for( n=0; n<points->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, 3, (*points)[n]);
	          str << endl ;
	        };
	      };

	      if( name == "connectivity" ){
	        for( n=0; n<points->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, n) ;
	          str << endl ;
	        };
	      };

	      if( name == "types" ){
	        int type_(1) ;
	        for( n=0; n<points->size(); n++) {
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, type_  ) ;
	          str << endl ;
	        };
	      };

	      if( name == "offsets" ){
	        int off_(0) ;
	        for( n=0; n<points->size(); n++) {
	          off_ += NumberOfElements( 1 ) ;
	          flush_ascii( str, indent ) ;
	          flush_ascii( str, off_  ) ;
	          str << endl ;
	        };
	      };

	    }

	    else{

	    	if( name == "Points" ){
	    		for( n=0; n<points->size(); n++) {
	    			flush_binary( str, (*points)[n]);
	    		 };
	        };

	    	if( name == "connectivity" ){
	    		for( n=0; n<points->size(); n++) {
	    		    flush_binary( str, n) ;
	    		   };
	    	};

	    	if( name == "types" ){
	    	int type_(1) ;
	    		for( n=0; n<points->size(); n++) {
	    		    flush_binary( str, type_  ) ;
	    		};
	    	};

	    	if( name == "offsets" ){
	    	int off_(0) ;
	    	     for( n=0; n<points->size(); n++) {
	    		     off_ += NumberOfElements( 1 ) ;
	    		     flush_binary( str, off_  ) ;
	    		    };
	         };


	      }

	  return ;

};




#include "libRA_RigidRot.hpp"

dvector2D ROTOTRASL3D::createRotationMatrix(double & angle, std::string dir)
{
	dvector2D matrix(3, dvector1D(3,0.0));

	int itype=2;
	if(dir=="x"){ itype = 0;}
	if(dir=="y"){ itype = 1;}

	switch(itype){

	case 0:	matrix[0][0] = 1.0;
			matrix[1][1] = cos(angle); matrix[1][2]= -1.0*sin(angle);
			matrix[2][2] = cos(angle); matrix[2][1]= sin(angle);
			break;

	case 1: matrix[0][0] = cos(angle); matrix[0][2]= sin(angle);
			matrix[1][1] = 1.0;
			matrix[2][2] = cos(angle); matrix[2][0]= -1.0*sin(angle);
			break;

	default:matrix[0][0] = cos(angle); matrix[0][1]= -1.0*sin(angle);
			matrix[1][1] = cos(angle); matrix[1][0]= sin(angle);
			matrix[2][2] = 1.0;
			break;
	}

	return(matrix);
}

dvector2D ROTOTRASL3D::transfMatrixToLocalSDR(dvector1D & dir, std::string label)
{
	dvector2D matrix(3, dvector1D(3,0.0));
	dvector1D dumvec;
	int n0, n1, n2;

	if(dir.size() != 3){std::cout<<"Error in transfMatrixLocalSDR. "
						"Given direction is not a 3-comp vector. Exiting"<<endl; return(matrix);}

	int itype = (label=="x")*1 + (label=="y")*2 + (label=="z")*3 -1;
	if(itype == -1){std::cout<<"Not suitable direction label"<<endl; return(matrix);}

	n0 = itype;
	n1 = (itype+1)%3;
	n2 = (itype+2)%3;

	matrix[n0] = dir/norm_2(dir);

	double maxval = abs(matrix[n0][0]);
	int max_cand = 0;
	//find maximum component on matrix[n0];
	for(int i=1; i<3; ++i){
		if(abs(matrix[n0][i])> maxval){
			maxval = abs(matrix[n0][i]);
			max_cand= i;
		}
	}

	dumvec.resize(3,1.0);
	int lcand = (3 + max_cand -1)%3;
	int rcand = (max_cand +1)%3;

	dumvec[max_cand] = -1.0*(matrix[n0][lcand] + matrix[n0][rcand])/matrix[n0][max_cand];
	matrix[n1] = dumvec/norm_2(dumvec);

	dumvec = Cross_Product(matrix[n0],matrix[n1]);
	matrix[n2] = dumvec/norm_2(dumvec);

	return(matrix);
}


dvector2D ROTOTRASL3D::rotAroundAxis(dvector2D & list, dvector1D & direction, dvector1D & origin, std::string label, double & theta){

	int sizeList = list.size();
	dvector2D result(sizeList, dvector1D(3,0));
	dvector1D support(3,0), work(3,0);

	//transformMatrix calc
	dvector2D transfM = transfMatrixToLocalSDR(direction, label);
	// its inverse evaluation
	dvector2D invTransfM(3, dvector1D(3,0));
	transpose(transfM, invTransfM);
	// elemental rotation
	dvector2D rotM =createRotationMatrix(theta, label);

//	matmul(rotM, transfM, transfM);
//	matmul(invTransfM, transfM, transfM);

//	matmul(transfM, origin, support);

	for(int i=0; i<sizeList; ++i){

		support = list[i] - origin;
		matmul(transfM, support, work);
		matmul(rotM,work,support);
		matmul(invTransfM,support,work);

		// translate on local
		//matmul(transfM, list[i],work);
		result[i] = work + origin;

	}
	return(result);
}

dvector2D ROTOTRASL3D::translation(dvector2D & list, dvector1D & transl){

	int sizeList = list.size();
	dvector2D result(sizeList, dvector1D(3,0));
		for(int i=0; i<sizeList; ++i){

		result[i] = list[i] - transl;

	}
	return(result);
}

